// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.10 (swiftlang-5.10.0.13 clang-1500.3.9.4)
// swift-module-flags: -target arm64-apple-ios13.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -enable-bare-slash-regex -module-name Telegraph
import CocoaAsyncSocket
import CommonCrypto
import Foundation
import HTTPParserC
import MobileCoreServices
import Security
import Swift
@_exported import Telegraph
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension Swift.Array {
  public func first<T>(ofType: T.Type) -> T?
  public func filter<T>(ofType: T.Type) -> [T]
}
open class Certificate : Swift.RawRepresentable {
  final public let rawValue: Security.SecCertificate
  required public init(rawValue: Security.SecCertificate)
  convenience public init?(derData: Foundation.Data)
  convenience public init?(derURL: Foundation.URL)
  public typealias RawValue = Security.SecCertificate
  @objc deinit
}
extension Telegraph.Certificate {
  public var commonName: Swift.String? {
    get
  }
}
extension Telegraph.Certificate {
  convenience public init(fromKeychain label: Swift.String) throws
  public func addToKeychain(label: Swift.String) throws
  public static func removeFromKeychain(label: Swift.String) throws
}
open class CertificateIdentity : Swift.RawRepresentable {
  final public let rawValue: Security.SecIdentity
  required public init(rawValue: Security.SecIdentity)
  convenience public init?(p12Data: Foundation.Data, passphrase: Swift.String)
  convenience public init?(p12URL: Foundation.URL, passphrase: Swift.String)
  public typealias RawValue = Security.SecIdentity
  @objc deinit
}
extension Telegraph.CertificateIdentity {
  convenience public init(fromKeychain label: Swift.String) throws
  public func addToKeychain(label: Swift.String) throws
  public static func removeFromKeychain(label: Swift.String) throws
}
extension Telegraph.CertificateIdentity {
  convenience public init?(p12Data: Foundation.Data)
  convenience public init?(p12URL: Foundation.URL)
}
extension Telegraph.HTTPConfig {
  public static var clientDefault: Telegraph.HTTPConfig {
    get
  }
}
extension Telegraph.WebSocketConfig {
  public static var clientDefault: Telegraph.WebSocketConfig {
    get
  }
}
extension Foundation.Data {
  public static let crlf: Foundation.Data
  public init(randomNumberOfBytes count: Swift.Int)
  public func hexEncodedString() -> Swift.String
  public mutating func mask(with maskBytes: [Swift.UInt8])
}
final public class DataStream {
  final public var position: Swift.Int {
    get
  }
  public init(data: Foundation.Data = Data())
  final public var hasBytesAvailable: Swift.Bool {
    get
  }
  final public func read() -> Swift.UInt8?
  final public func read(count: Swift.Int) -> Foundation.Data
  final public func readToEnd() -> Foundation.Data
  @objc deinit
}
extension Foundation.DateFormatter {
  @available(*, deprecated, renamed: "rfc1123")
  public var rfc7231: Foundation.DateFormatter {
    get
  }
}
extension Telegraph.DispatchTimer {
  @available(*, deprecated, message: "no longer supported, use start(at:) to run the timer at a later time")
  public static func run(after: Foundation.TimeInterval, interval: Foundation.TimeInterval = 0, queue: Dispatch.DispatchQueue, execute block: @escaping () -> Swift.Void) -> Telegraph.DispatchTimer
  @available(*, deprecated, message: "no longer supported, use start(at:) to run the timer at a later time")
  final public func start(after: Foundation.TimeInterval)
}
extension Foundation.FileManager {
  @available(*, deprecated, message: "use <url>.mimeType")
  public func mimeType(of url: Foundation.URL) -> Swift.String
}
extension Telegraph.HTTPHeaderName {
  @available(*, deprecated, message: "construct lower cased names manually")
  public static var forceLowerCased: Swift.Bool
}
extension Telegraph.HTTPMethod {
  @available(*, deprecated, renamed: "GET")
  public static var get: Telegraph.HTTPMethod
  @available(*, deprecated, renamed: "HEAD")
  public static var head: Telegraph.HTTPMethod
  @available(*, deprecated, renamed: "DELETE")
  public static var delete: Telegraph.HTTPMethod
  @available(*, deprecated, renamed: "OPTIONS")
  public static var options: Telegraph.HTTPMethod
  @available(*, deprecated, renamed: "POST")
  public static var post: Telegraph.HTTPMethod
  @available(*, deprecated, renamed: "PUT")
  public static var put: Telegraph.HTTPMethod
  @available(*, deprecated, renamed: "init(name:)")
  public init(rawValue: Swift.String)
  @available(*, deprecated, renamed: "init(name:)")
  public static func method(_ name: Swift.String) -> Telegraph.HTTPMethod
}
@available(*, deprecated, message: "these specific errors are no longer thrown")
public enum HTTPRouteError : Swift.Error {
  case invalidURI
  public static func == (a: Telegraph.HTTPRouteError, b: Telegraph.HTTPRouteError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Telegraph.HTTPStatus {
  @available(*, deprecated, message: "return nil from your handler (this status is used by Nginx, not part of the spec)")
  public static let noResponse: Telegraph.HTTPStatus
}
@available(*, deprecated, message: "use HTTPStatus, for example .ok or .notFound")
public typealias HTTPStatusCode = Telegraph.HTTPStatus
extension Telegraph.HTTPResponse {
  @available(*, deprecated, message: "use DateFormatter.rfc1123 or Date's rfc1123 variable")
  public static let dateFormatter: Foundation.DateFormatter
  @available(*, deprecated, renamed: "init(status:data:)")
  convenience public init(_ status: Telegraph.HTTPStatus = .ok, data: Foundation.Data)
  @available(*, deprecated, message: "use keepAlive instead, this setter only handles true properly")
  public var closeAfterWrite: Swift.Bool {
    get
    set
  }
}
extension Telegraph.HTTPVersion {
  @available(*, deprecated, renamed: "init(major:minor:)")
  public init(_ major: Swift.UInt, _ minor: Swift.UInt)
}
extension Telegraph.Server {
  @available(*, deprecated, renamed: "start(port:)")
  public func start(onPort port: Swift.UInt16) throws
  @available(*, deprecated, renamed: "start(port:interface:)")
  public func start(onInterface interface: Swift.String?, port: Swift.UInt16 = 0) throws
  @available(swift, obsoleted: 5, renamed: "responseFor(request:)")
  public func handleIncoming(request: Telegraph.HTTPRequest) throws -> Telegraph.HTTPResponse?
  @available(swift, obsoleted: 5, renamed: "responseFor(error:)")
  public func handleIncoming(error: any Swift.Error) throws -> Telegraph.HTTPResponse?
}
@_hasMissingDesignatedInitializers final public class DispatchTimer {
  @objc deinit
}
extension Telegraph.DispatchTimer {
  public static func run(interval: Foundation.TimeInterval, queue: Dispatch.DispatchQueue, execute block: @escaping () -> Swift.Void) -> Telegraph.DispatchTimer
  public static func run(at: Foundation.Date, interval: Foundation.TimeInterval = 0, queue: Dispatch.DispatchQueue, execute block: @escaping () -> Swift.Void) -> Telegraph.DispatchTimer
}
public struct Endpoint : Swift.Hashable {
  public typealias Host = Swift.String
  public typealias Port = Swift.Int
  public var host: Telegraph.Endpoint.Host
  public var port: Telegraph.Endpoint.Port
  public init(host: Telegraph.Endpoint.Host, port: Telegraph.Endpoint.Port)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Telegraph.Endpoint, b: Telegraph.Endpoint) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Telegraph.Endpoint {
  public init?(url: Foundation.URL)
  public init(host: Telegraph.Endpoint.Host, port: Swift.UInt16)
}
extension Foundation.FileManager {
  public func mimeType(pathExtension: Swift.String) -> Swift.String
}
public struct HTTPConfig {
  public var readTimeout: Swift.Double
  public var writeHeaderTimeout: Swift.Double
  public var writeBodyTimeout: Swift.Double
  public var errorHandler: any Telegraph.HTTPErrorHandler
  public var requestHandlers: [any Telegraph.HTTPRequestHandler] {
    get
    set
  }
  public init(requestHandlers: [any Telegraph.HTTPRequestHandler])
}
public protocol HTTPConnectionDelegate : AnyObject {
  func connection(_ httpConnection: Telegraph.HTTPConnection, didCloseWithError error: (any Swift.Error)?)
  func connection(_ httpConnection: Telegraph.HTTPConnection, handleIncomingRequest request: Telegraph.HTTPRequest, error: (any Swift.Error)?)
  func connection(_ httpConnection: Telegraph.HTTPConnection, handleIncomingResponse response: Telegraph.HTTPResponse, error: (any Swift.Error)?)
  func connection(_ httpConnection: Telegraph.HTTPConnection, handleUpgradeByRequest request: Telegraph.HTTPRequest)
}
public class HTTPConnection : Telegraph.TCPConnection {
  weak public var delegate: (any Telegraph.HTTPConnectionDelegate)?
  required public init(socket: Telegraph.TCPSocket, config: Telegraph.HTTPConfig)
  public func open()
  public func close(immediately: Swift.Bool)
  public func upgrade() -> (Telegraph.TCPSocket, Foundation.Data?)
  public func send(data: Foundation.Data, timeout: Foundation.TimeInterval)
  public func send(request: Telegraph.HTTPRequest)
  public func send(response: Telegraph.HTTPResponse, toRequest request: Telegraph.HTTPRequest)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension Telegraph.HTTPConnection {
  public var localEndpoint: Telegraph.Endpoint? {
    get
  }
  public var remoteEndpoint: Telegraph.Endpoint? {
    get
  }
}
extension Telegraph.HTTPConnection : Telegraph.TCPSocketDelegate {
  public func socketDidOpen(_ socket: Telegraph.TCPSocket)
  public func socketDidClose(_ socket: Telegraph.TCPSocket, error: (any Swift.Error)?)
  public func socketDidRead(_ socket: Telegraph.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  public func socketDidWrite(_ socket: Telegraph.TCPSocket, tag: Swift.Int)
}
public enum HTTPError : Swift.Error {
  case unexpectedStreamEnd
  case connectionShouldBeClosed
  case protocolNotSupported
  case invalidContentLength
  case invalidHeader
  case invalidRequest
  case invalidMethod
  case invalidURI
  case invalidVersion
  case headerOverflow
  case parseFailed(code: Swift.Int)
}
extension Telegraph.HTTPError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Telegraph.HTTPError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class HTTPErrorDefaultHandler : Telegraph.HTTPErrorHandler {
  public func respond(to error: any Swift.Error) -> Telegraph.HTTPResponse?
  @objc deinit
}
public protocol HTTPErrorHandler {
  func respond(to error: any Swift.Error) -> Telegraph.HTTPResponse?
}
open class HTTPFileHandler : Telegraph.HTTPRequestHandler {
  public var directoryURL: Foundation.URL {
    get
  }
  public var baseURI: Telegraph.URI {
    get
  }
  public var index: Swift.String? {
    get
  }
  public typealias ByteRange = (Swift.UInt64, Swift.UInt64?)
  public init(directoryURL: Foundation.URL, baseURI: Telegraph.URI = .root, index: Swift.String? = "index.html")
  open func respond(to request: Telegraph.HTTPRequest, nextHandler: (Telegraph.HTTPRequest) throws -> Telegraph.HTTPResponse?) throws -> Telegraph.HTTPResponse?
  open func responseForURL(_ url: Foundation.URL, byteRange: Telegraph.HTTPFileHandler.ByteRange?, request: Telegraph.HTTPRequest) throws -> Telegraph.HTTPResponse
  @objc deinit
}
public typealias HTTPHeaders = [Telegraph.HTTPHeaderName : Swift.String]
public struct HTTPHeaderName : Swift.Hashable {
  public static func == (lhs: Telegraph.HTTPHeaderName, rhs: Telegraph.HTTPHeaderName) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Telegraph.HTTPHeaderName : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Telegraph.HTTPHeaderName : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Swift.Dictionary where Key == Telegraph.HTTPHeaderName, Value == Swift.String {
  public static var empty: Telegraph.HTTPHeaders {
    get
  }
  public subscript(key: Swift.String) -> Swift.String? {
    get
    set
  }
}
extension Telegraph.HTTPHeaderName {
  public static let accept: Telegraph.HTTPHeaderName
  public static let acceptCharset: Telegraph.HTTPHeaderName
  public static let acceptEncoding: Telegraph.HTTPHeaderName
  public static let acceptLanguage: Telegraph.HTTPHeaderName
  public static let acceptRanges: Telegraph.HTTPHeaderName
  public static let accessControlAllowOrigin: Telegraph.HTTPHeaderName
  public static let accessControlAllowHeaders: Telegraph.HTTPHeaderName
  public static let accessControlAllowMethods: Telegraph.HTTPHeaderName
  public static let accessControlMaxAge: Telegraph.HTTPHeaderName
  public static let age: Telegraph.HTTPHeaderName
  public static let allow: Telegraph.HTTPHeaderName
  public static let authorization: Telegraph.HTTPHeaderName
  public static let cacheControl: Telegraph.HTTPHeaderName
  public static let connection: Telegraph.HTTPHeaderName
  public static let cookie: Telegraph.HTTPHeaderName
  public static let contentDisposition: Telegraph.HTTPHeaderName
  public static let contentEncoding: Telegraph.HTTPHeaderName
  public static let contentLanguage: Telegraph.HTTPHeaderName
  public static let contentLength: Telegraph.HTTPHeaderName
  public static let contentRange: Telegraph.HTTPHeaderName
  public static let contentType: Telegraph.HTTPHeaderName
  public static let date: Telegraph.HTTPHeaderName
  public static let eTag: Telegraph.HTTPHeaderName
  public static let expect: Telegraph.HTTPHeaderName
  public static let expires: Telegraph.HTTPHeaderName
  public static let forwarded: Telegraph.HTTPHeaderName
  public static let host: Telegraph.HTTPHeaderName
  public static let ifModifiedSince: Telegraph.HTTPHeaderName
  public static let lastModified: Telegraph.HTTPHeaderName
  public static let location: Telegraph.HTTPHeaderName
  public static let origin: Telegraph.HTTPHeaderName
  public static let pragma: Telegraph.HTTPHeaderName
  public static let range: Telegraph.HTTPHeaderName
  public static let referer: Telegraph.HTTPHeaderName
  public static let refresh: Telegraph.HTTPHeaderName
  public static let server: Telegraph.HTTPHeaderName
  public static let setCookie: Telegraph.HTTPHeaderName
  public static let strictTransportSecurity: Telegraph.HTTPHeaderName
  public static let transferEncoding: Telegraph.HTTPHeaderName
  public static let userAgent: Telegraph.HTTPHeaderName
  public static let upgrade: Telegraph.HTTPHeaderName
}
extension Swift.Dictionary where Key == Telegraph.HTTPHeaderName, Value == Swift.String {
  public var accept: Swift.String? {
    get
    set
  }
  public var acceptCharset: Swift.String? {
    get
    set
  }
  public var acceptEncoding: Swift.String? {
    get
    set
  }
  public var acceptLanguage: Swift.String? {
    get
    set
  }
  public var acceptRanges: Swift.String? {
    get
    set
  }
  public var accessControlAllowOrigin: Swift.String? {
    get
    set
  }
  public var accessControlAllowHeaders: Swift.String? {
    get
    set
  }
  public var accessControlAllowMethods: Swift.String? {
    get
    set
  }
  public var accessControlMaxAge: Swift.String? {
    get
    set
  }
  public var age: Swift.String? {
    get
    set
  }
  public var allow: Swift.String? {
    get
    set
  }
  public var authorization: Swift.String? {
    get
    set
  }
  public var cacheControl: Swift.String? {
    get
    set
  }
  public var connection: Swift.String? {
    get
    set
  }
  public var cookie: Swift.String? {
    get
    set
  }
  public var contentDisposition: Swift.String? {
    get
    set
  }
  public var contentEncoding: Swift.String? {
    get
    set
  }
  public var contentLanguage: Swift.String? {
    get
    set
  }
  public var contentLength: Swift.Int? {
    get
    set
  }
  public var contentRange: Swift.String? {
    get
    set
  }
  public var contentType: Swift.String? {
    get
    set
  }
  public var date: Swift.String? {
    get
    set
  }
  public var eTag: Swift.String? {
    get
    set
  }
  public var expect: Swift.String? {
    get
    set
  }
  public var expires: Swift.String? {
    get
    set
  }
  public var forwarded: Swift.String? {
    get
    set
  }
  public var host: Swift.String? {
    get
    set
  }
  public var ifModifiedSince: Swift.String? {
    get
    set
  }
  public var lastModified: Swift.String? {
    get
    set
  }
  public var location: Swift.String? {
    get
    set
  }
  public var origin: Swift.String? {
    get
    set
  }
  public var pragma: Swift.String? {
    get
    set
  }
  public var range: Swift.String? {
    get
    set
  }
  public var referer: Swift.String? {
    get
    set
  }
  public var refresh: Swift.String? {
    get
    set
  }
  public var server: Swift.String? {
    get
    set
  }
  public var setCookie: Swift.String? {
    get
    set
  }
  public var strictTransportSecurity: Swift.String? {
    get
    set
  }
  public var transferEncoding: Swift.String? {
    get
    set
  }
  public var userAgent: Swift.String? {
    get
    set
  }
  public var upgrade: Swift.String? {
    get
    set
  }
}
extension Telegraph.HTTPHeaderName {
  public static let webSocketAccept: Telegraph.HTTPHeaderName
  public static let webSocketKey: Telegraph.HTTPHeaderName
  public static let webSocketProtocol: Telegraph.HTTPHeaderName
  public static let webSocketVersion: Telegraph.HTTPHeaderName
}
extension Swift.Dictionary where Key == Telegraph.HTTPHeaderName, Value == Swift.String {
  public var webSocketAccept: Swift.String? {
    get
    set
  }
  public var webSocketKey: Swift.String? {
    get
    set
  }
  public var webSocketProtocol: Swift.String? {
    get
    set
  }
  public var webSocketVersion: Swift.String? {
    get
    set
  }
}
open class HTTPMessage {
  public var version: Telegraph.HTTPVersion
  public var headers: Telegraph.HTTPHeaders
  public var body: Foundation.Data
  public init(version: Telegraph.HTTPVersion = .default, headers: Telegraph.HTTPHeaders = .empty, body: Foundation.Data = Data())
  open func prepareForWrite()
  public func write(to stream: any Telegraph.WriteStream, headerTimeout: Foundation.TimeInterval, bodyTimeout: Foundation.TimeInterval)
  open func writeHeader(to stream: any Telegraph.WriteStream, timeout: Foundation.TimeInterval)
  open func writeBody(to stream: any Telegraph.WriteStream, timeout: Foundation.TimeInterval)
  @objc deinit
}
extension Telegraph.HTTPMessage {
  public var keepAlive: Swift.Bool {
    get
  }
  public var isConnectionUpgrade: Swift.Bool {
    get
  }
}
extension Telegraph.HTTPMessage {
  public static let webSocketMagicGUID: Swift.String
  public static let webSocketProtocol: Swift.String
  public static let webSocketVersion: Swift.String
  public var isWebSocketUpgrade: Swift.Bool {
    get
  }
}
extension Telegraph.HTTPRequest {
  public static func webSocketHandshake(host: Swift.String, port: Swift.Int = 80, protocolName: Swift.String? = nil) -> Telegraph.HTTPRequest
  public func webSocketHandshake(host: Swift.String, port: Swift.Int = 80, protocolName: Swift.String? = nil)
}
extension Telegraph.HTTPResponse {
  public static func webSocketHandshake(key: Swift.String, protocolName: Swift.String? = nil) -> Telegraph.HTTPResponse
  public func webSocketHandshake(key: Swift.String, protocolName: Swift.String? = nil)
  public var isWebSocketHandshake: Swift.Bool {
    get
  }
}
public struct HTTPMethod : Swift.Hashable {
  public let name: Swift.String
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Telegraph.HTTPMethod, b: Telegraph.HTTPMethod) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Telegraph.HTTPMethod {
  public static let GET: Telegraph.HTTPMethod
  public static let HEAD: Telegraph.HTTPMethod
  public static let DELETE: Telegraph.HTTPMethod
  public static let POST: Telegraph.HTTPMethod
  public static let PUT: Telegraph.HTTPMethod
  public static let OPTIONS: Telegraph.HTTPMethod
  public static let CONNECT: Telegraph.HTTPMethod
  public static let TRACE: Telegraph.HTTPMethod
  public static let PATCH: Telegraph.HTTPMethod
}
extension Telegraph.HTTPMethod : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Telegraph.HTTPMethod : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
final public class HTTPParser {
  final public var message: Telegraph.HTTPMessage? {
    get
  }
  final public var isMessageComplete: Swift.Bool {
    get
  }
  final public var isUpgradeDetected: Swift.Bool {
    get
  }
  public init()
  @discardableResult
  final public func parse(data: Foundation.Data) throws -> Swift.Int
  final public func reset()
  @objc deinit
}
open class HTTPRequest : Telegraph.HTTPMessage {
  public typealias Params = [Swift.String : Swift.String]
  public var method: Telegraph.HTTPMethod
  public var uri: Telegraph.URI
  public var params: Telegraph.HTTPRequest.Params
  public init(_ method: Telegraph.HTTPMethod = .GET, uri: Telegraph.URI = .root, version: Telegraph.HTTPVersion = .default, headers: Telegraph.HTTPHeaders = .empty, body: Foundation.Data = Data())
  override open func prepareForWrite()
  @objc deinit
}
extension Telegraph.HTTPRequest : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Telegraph.HTTPRequest {
  public func setHostHeader(host: Swift.String?, port: Swift.Int? = nil)
}
public protocol HTTPRequestHandler {
  func respond(to request: Telegraph.HTTPRequest, nextHandler: (Telegraph.HTTPRequest) throws -> Telegraph.HTTPResponse?) throws -> Telegraph.HTTPResponse?
}
extension Telegraph.HTTPRequest {
  public typealias Handler = (Telegraph.HTTPRequest) throws -> Telegraph.HTTPResponse?
}
open class HTTPResponse : Telegraph.HTTPMessage {
  public typealias Handler = (Telegraph.HTTPResponse, any Swift.Error) -> Swift.Void
  public var status: Telegraph.HTTPStatus
  public init(_ status: Telegraph.HTTPStatus = .ok, version: Telegraph.HTTPVersion = .default, headers: Telegraph.HTTPHeaders = .empty, body: Foundation.Data = Data(), isComplete: Swift.Bool = true)
  override open func prepareForWrite()
  @objc deinit
}
extension Telegraph.HTTPResponse {
  convenience public init(_ status: Telegraph.HTTPStatus = .ok, headers: Telegraph.HTTPHeaders = .empty, content: Swift.String)
  convenience public init(_ status: Telegraph.HTTPStatus = .internalServerError, headers: Telegraph.HTTPHeaders = .empty, error: any Swift.Error)
}
extension Telegraph.HTTPResponse : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPRoute {
  public let methods: Swift.Set<Telegraph.HTTPMethod>?
  public let handler: Telegraph.HTTPRequest.Handler
  public let regex: Telegraph.Regex?
  public let params: [Telegraph.HTTPRequest.Params.Key]
  public init(methods: Swift.Set<Telegraph.HTTPMethod>? = nil, regex pattern: Swift.String? = nil, handler: @escaping Telegraph.HTTPRequest.Handler) throws
  public init(methods: Swift.Set<Telegraph.HTTPMethod>? = nil, uri: Swift.String, handler: @escaping Telegraph.HTTPRequest.Handler) throws
}
extension Telegraph.HTTPRoute {
  public func canHandle(method: Telegraph.HTTPMethod) -> Swift.Bool
  public func canHandle(path: Swift.String) -> (Swift.Bool, Telegraph.HTTPRequest.Params)
}
@_hasMissingDesignatedInitializers open class HTTPRouteHandler : Telegraph.HTTPRequestHandler {
  public var routes: [Telegraph.HTTPRoute]
  public var implicitHeadRequests: Swift.Bool
  open func respond(to request: Telegraph.HTTPRequest, nextHandler: (Telegraph.HTTPRequest) throws -> Telegraph.HTTPResponse?) throws -> Telegraph.HTTPResponse?
  @objc deinit
}
public struct HTTPStatus : Swift.Hashable {
  public let code: Swift.Int
  public let phrase: Swift.String
  public let strict: Swift.Bool
  public init(code: Swift.Int, phrase: Swift.String, strict: Swift.Bool = false)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Telegraph.HTTPStatus {
  public var isInformational: Swift.Bool {
    get
  }
  public var isSuccess: Swift.Bool {
    get
  }
  public var isRedirection: Swift.Bool {
    get
  }
  public var isClientError: Swift.Bool {
    get
  }
  public var isServerError: Swift.Bool {
    get
  }
  public var supportsBody: Swift.Bool {
    get
  }
}
extension Telegraph.HTTPStatus {
  public static func == (lhs: Telegraph.HTTPStatus, rhs: Telegraph.HTTPStatus) -> Swift.Bool
}
extension Telegraph.HTTPStatus : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Telegraph.HTTPStatus {
  public static let `continue`: Telegraph.HTTPStatus
  public static let switchingProtocols: Telegraph.HTTPStatus
  public static let processing: Telegraph.HTTPStatus
}
extension Telegraph.HTTPStatus {
  public static let ok: Telegraph.HTTPStatus
  public static let created: Telegraph.HTTPStatus
  public static let accepted: Telegraph.HTTPStatus
  public static let nonAuthoritativeInformation: Telegraph.HTTPStatus
  public static let noContent: Telegraph.HTTPStatus
  public static let resetContent: Telegraph.HTTPStatus
  public static let partialContent: Telegraph.HTTPStatus
  public static let multiStatus: Telegraph.HTTPStatus
  public static let alreadyReported: Telegraph.HTTPStatus
  public static let imUsed: Telegraph.HTTPStatus
}
extension Telegraph.HTTPStatus {
  public static let multipleChoices: Telegraph.HTTPStatus
  public static let movedPermanently: Telegraph.HTTPStatus
  public static let found: Telegraph.HTTPStatus
  public static let seeOther: Telegraph.HTTPStatus
  public static let notModified: Telegraph.HTTPStatus
  public static let useProxy: Telegraph.HTTPStatus
  public static let temporaryRedirect: Telegraph.HTTPStatus
  public static let permanentRedirect: Telegraph.HTTPStatus
}
extension Telegraph.HTTPStatus {
  public static let badRequest: Telegraph.HTTPStatus
  public static let unauthorized: Telegraph.HTTPStatus
  public static let paymentRequired: Telegraph.HTTPStatus
  public static let forbidden: Telegraph.HTTPStatus
  public static let notFound: Telegraph.HTTPStatus
  public static let methodNotAllowed: Telegraph.HTTPStatus
  public static let notAcceptable: Telegraph.HTTPStatus
  public static let proxyAuthenticationRequired: Telegraph.HTTPStatus
  public static let requestTimeout: Telegraph.HTTPStatus
  public static let conflict: Telegraph.HTTPStatus
  public static let gone: Telegraph.HTTPStatus
  public static let lengthRequired: Telegraph.HTTPStatus
  public static let preconditionFailed: Telegraph.HTTPStatus
  public static let payloadTooLarge: Telegraph.HTTPStatus
  public static let uriTooLong: Telegraph.HTTPStatus
  public static let unsupportedMediaType: Telegraph.HTTPStatus
  public static let rangeNotSatisfiable: Telegraph.HTTPStatus
  public static let expectationFailed: Telegraph.HTTPStatus
  public static let misdirectedRequest: Telegraph.HTTPStatus
  public static let unprocessableEntity: Telegraph.HTTPStatus
  public static let locked: Telegraph.HTTPStatus
  public static let failedDependency: Telegraph.HTTPStatus
  public static let upgradeRequired: Telegraph.HTTPStatus
  public static let preconditionRequired: Telegraph.HTTPStatus
  public static let tooManyRequests: Telegraph.HTTPStatus
  public static let requestHeaderFieldsTooLarge: Telegraph.HTTPStatus
  public static let unavailableForLegalReasons: Telegraph.HTTPStatus
}
extension Telegraph.HTTPStatus {
  public static let internalServerError: Telegraph.HTTPStatus
  public static let notImplemented: Telegraph.HTTPStatus
  public static let badGateway: Telegraph.HTTPStatus
  public static let serviceUnavailable: Telegraph.HTTPStatus
  public static let gatewayTimeout: Telegraph.HTTPStatus
  public static let httpVersionNotSupported: Telegraph.HTTPStatus
  public static let variantAlsoNegotiates: Telegraph.HTTPStatus
  public static let insufficientStorage: Telegraph.HTTPStatus
  public static let loopDetected: Telegraph.HTTPStatus
  public static let notExtended: Telegraph.HTTPStatus
  public static let networkAuthenticationRequired: Telegraph.HTTPStatus
}
public struct HTTPVersion {
  public let major: Swift.UInt
  public let minor: Swift.UInt
  public init(major: Swift.UInt, minor: Swift.UInt)
}
extension Telegraph.HTTPVersion {
  public static let `default`: Telegraph.HTTPVersion
}
extension Telegraph.HTTPVersion : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
open class HTTPWebSocketHandler : Telegraph.HTTPRequestHandler {
  public init(protocolName: Swift.String? = nil)
  open func respond(to request: Telegraph.HTTPRequest, nextHandler: (Telegraph.HTTPRequest) throws -> Telegraph.HTTPResponse?) throws -> Telegraph.HTTPResponse?
  @objc deinit
}
public enum KeychainError : Swift.Error {
  case invalidResult
  case itemAlreadyExists
  case itemNotFound
  case other(code: Darwin.OSStatus)
}
extension Telegraph.KeychainError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Telegraph.KeychainError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class KeychainManager {
  public static let shared: Telegraph.KeychainManager
  public var accessibility: CoreFoundation.CFString
  public typealias KeychainClass = CoreFoundation.CFString
  public typealias KeychainValue = Swift.AnyObject
  public typealias KeychainQuery = [Foundation.NSString : Swift.AnyObject]
  @objc deinit
}
extension Telegraph.KeychainManager {
  public func importPKCS12(data: Foundation.Data, passphrase: Swift.String, options: Telegraph.KeychainManager.KeychainQuery = KeychainQuery()) -> Security.SecIdentity?
}
extension Telegraph.KeychainManager {
  public func add(value: Telegraph.KeychainManager.KeychainValue, label: Swift.String, options: Telegraph.KeychainManager.KeychainQuery = KeychainQuery()) throws
  public func find<T>(_ kClass: Telegraph.KeychainManager.KeychainClass, label: Swift.String, options: Telegraph.KeychainManager.KeychainQuery = KeychainQuery()) throws -> T
  public func remove(_ kClass: Telegraph.KeychainManager.KeychainClass, label: Swift.String, options: Telegraph.KeychainManager.KeychainQuery = KeychainQuery()) throws
}
public typealias Regex = Foundation.NSRegularExpression
public struct RFC1123 {
  public static var formatter: Foundation.DateFormatter
}
extension Foundation.DateFormatter {
  public static var rfc1123: Foundation.DateFormatter {
    get
  }
}
extension Foundation.Date {
  public var rfc1123: Swift.String {
    get
  }
}
open class Server {
  weak public var delegate: (any Telegraph.ServerDelegate)?
  public var delegateQueue: Dispatch.DispatchQueue
  public var httpConfig: Telegraph.HTTPConfig
  public var webSocketConfig: Telegraph.WebSocketConfig
  weak public var webSocketDelegate: (any Telegraph.ServerWebSocketDelegate)?
  public init()
  public init(identity: Telegraph.CertificateIdentity, caCertificates: [Telegraph.Certificate])
  open func start(port: Telegraph.Endpoint.Port = 0, interface: Swift.String? = nil) throws
  open func stop(immediately: Swift.Bool = false)
  open func handleIncoming(socket: Telegraph.TCPSocket)
  open func handleIncoming(request: Telegraph.HTTPRequest, connection: Telegraph.HTTPConnection, error: (any Swift.Error)?)
  open func handleUpgrade(request: Telegraph.HTTPRequest, connection: Telegraph.HTTPConnection)
  open func responseFor(request: Telegraph.HTTPRequest) throws -> Telegraph.HTTPResponse?
  open func responseFor(error: any Swift.Error) -> Telegraph.HTTPResponse?
  @objc deinit
}
extension Telegraph.Server {
  public var concurrency: Swift.Int {
    get
    set
  }
  public var port: Telegraph.Endpoint.Port {
    get
  }
  public var isRunning: Swift.Bool {
    get
  }
  public var isSecure: Swift.Bool {
    get
  }
  public var httpConnectionCount: Swift.Int {
    get
  }
  public var webSocketCount: Swift.Int {
    get
  }
  public var webSockets: [any Telegraph.WebSocket] {
    get
  }
}
extension Telegraph.Server : Telegraph.TCPListenerDelegate {
  public func listener(_ listener: Telegraph.TCPListener, didAcceptSocket socket: Telegraph.TCPSocket)
  public func listenerDisconnected(_ listener: Telegraph.TCPListener, error: (any Swift.Error)?)
}
extension Telegraph.Server : Telegraph.HTTPConnectionDelegate {
  public func connection(_ httpConnection: Telegraph.HTTPConnection, handleIncomingRequest request: Telegraph.HTTPRequest, error: (any Swift.Error)?)
  public func connection(_ httpConnection: Telegraph.HTTPConnection, handleIncomingResponse response: Telegraph.HTTPResponse, error: (any Swift.Error)?)
  public func connection(_ httpConnection: Telegraph.HTTPConnection, handleUpgradeByRequest request: Telegraph.HTTPRequest)
  public func connection(_ httpConnection: Telegraph.HTTPConnection, didCloseWithError error: (any Swift.Error)?)
}
extension Telegraph.Server : Telegraph.WebSocketConnectionDelegate {
  public func connection(_ webSocketConnection: Telegraph.WebSocketConnection, didReceiveMessage message: Telegraph.WebSocketMessage)
  public func connection(_ webSocketConnection: Telegraph.WebSocketConnection, didSendMessage message: Telegraph.WebSocketMessage)
  public func connection(_ webSocketConnection: Telegraph.WebSocketConnection, didCloseWithError error: (any Swift.Error)?)
}
extension Telegraph.HTTPConfig {
  public static var serverDefault: Telegraph.HTTPConfig {
    get
  }
}
extension Telegraph.WebSocketConfig {
  public static var serverDefault: Telegraph.WebSocketConfig {
    get
  }
}
extension Telegraph.Server {
  public func route(_ method: Telegraph.HTTPMethod, _ uri: Swift.String, _ handler: @escaping Telegraph.HTTPRequest.Handler)
  public func route(_ method: Telegraph.HTTPMethod, regex: Swift.String, _ handler: @escaping Telegraph.HTTPRequest.Handler)
  public func route(_ httpRoute: Telegraph.HTTPRoute)
}
extension Telegraph.Server {
  public func serveBundle(_ bundle: Foundation.Bundle, _ uri: Swift.String = "/", index: Swift.String? = "index.html")
  public func serveDirectory(_ url: Foundation.URL, _ uri: Swift.String = "/", index: Swift.String? = "index.html")
}
extension Telegraph.Server {
  public func route(_ method: Telegraph.HTTPMethod, _ uri: Swift.String, response: @escaping () -> Telegraph.HTTPResponse)
  public func route(_ method: Telegraph.HTTPMethod, _ uri: Swift.String, status: @escaping () -> Telegraph.HTTPStatus)
  public func route(_ method: Telegraph.HTTPMethod, _ uri: Swift.String, content: @escaping () -> (Telegraph.HTTPStatus, Swift.String))
}
public protocol ServerDelegate : AnyObject {
  func serverDidStop(_ server: Telegraph.Server, error: (any Swift.Error)?)
}
public protocol ServerWebSocketDelegate : AnyObject {
  func server(_ server: Telegraph.Server, webSocketDidConnect webSocket: any Telegraph.WebSocket, handshake: Telegraph.HTTPRequest)
  func server(_ server: Telegraph.Server, webSocketDidDisconnect webSocket: any Telegraph.WebSocket, error: (any Swift.Error)?)
  func server(_ server: Telegraph.Server, webSocket: any Telegraph.WebSocket, didReceiveMessage message: Telegraph.WebSocketMessage)
  func server(_ server: Telegraph.Server, webSocket: any Telegraph.WebSocket, didSendMessage message: Telegraph.WebSocketMessage)
  func serverDidDisconnect(_ server: Telegraph.Server)
}
extension Telegraph.ServerWebSocketDelegate {
  public func server(_ server: Telegraph.Server, webSocket: any Telegraph.WebSocket, didSendMessage message: Telegraph.WebSocketMessage)
  public func serverDidDisconnect(_ server: Telegraph.Server)
}
public struct SHA1 {
  public let digest: Foundation.Data
  public init(data: Foundation.Data)
}
extension Telegraph.SHA1 {
  public static func hash(_ data: Foundation.Data) -> Foundation.Data
  public static func hash(_ string: Swift.String) -> Foundation.Data
}
public protocol ReadStream {
  func read(timeout: Foundation.TimeInterval)
}
public protocol WriteStream {
  func flush()
  func write(data: Foundation.Data, timeout: Foundation.TimeInterval)
}
extension Swift.String {
  public var base64: Swift.String {
    get
  }
  public var utf8Data: Foundation.Data {
    get
  }
  public func truncate(count: Swift.Int, ellipses: Swift.Bool = true) -> Swift.String
}
@_hasMissingDesignatedInitializers public class SynchronizedSet<Element> where Element : Swift.Hashable {
  @objc deinit
}
extension Telegraph.SynchronizedSet {
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension Telegraph.SynchronizedSet {
  public func insert(_ element: Element)
  public func remove(_ element: Element)
}
extension Telegraph.SynchronizedSet {
  public func contains(_ element: Element) -> Swift.Bool
  public func forEach(_ body: (Element) -> Swift.Void)
}
extension Telegraph.SynchronizedSet {
  public func toArray() -> [Element]
}
public protocol TCPConnection : AnyObject, Swift.Hashable {
  var localEndpoint: Telegraph.Endpoint? { get }
  var remoteEndpoint: Telegraph.Endpoint? { get }
  func open()
  func close(immediately: Swift.Bool)
}
extension Telegraph.TCPConnection {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol TCPListenerDelegate : AnyObject {
  func listener(_ listener: Telegraph.TCPListener, didAcceptSocket socket: Telegraph.TCPSocket)
  func listenerDisconnected(_ listener: Telegraph.TCPListener, error: (any Swift.Error)?)
}
@objc final public class TCPListener : ObjectiveC.NSObject {
  weak final public var delegate: (any Telegraph.TCPListenerDelegate)?
  final public let interface: Swift.String?
  final public let tlsConfig: Telegraph.TLSConfig?
  public init(port: Telegraph.Endpoint.Port, interface: Swift.String? = nil, tlsConfig: Telegraph.TLSConfig? = nil)
  final public var isListening: Swift.Bool {
    get
  }
  final public var port: Telegraph.Endpoint.Port {
    get
  }
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  final public func start(queue: Dispatch.DispatchQueue) throws
  final public func stop()
  @objc deinit
}
extension Telegraph.TCPListener : CocoaAsyncSocket.GCDAsyncSocketDelegate {
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didAcceptNewSocket newSocket: CocoaAsyncSocket.GCDAsyncSocket)
  @objc final public func socketDidDisconnect(_ sock: CocoaAsyncSocket.GCDAsyncSocket, withError err: (any Swift.Error)?)
}
public enum TCPSocketClose {
  case immediately
  case afterReading
  case afterWriting
  case afterReadingAndWriting
  public static func == (a: Telegraph.TCPSocketClose, b: Telegraph.TCPSocketClose) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TCPSocketDelegate : AnyObject {
  func socketDidOpen(_ socket: Telegraph.TCPSocket)
  func socketDidClose(_ socket: Telegraph.TCPSocket, error: (any Swift.Error)?)
  func socketDidRead(_ socket: Telegraph.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  func socketDidWrite(_ socket: Telegraph.TCPSocket, tag: Swift.Int)
}
@objc @_hasMissingDesignatedInitializers final public class TCPSocket : ObjectiveC.NSObject {
  final public let endpoint: Telegraph.Endpoint
  weak final public var delegate: (any Telegraph.TCPSocketDelegate)?
  public init(endpoint: Telegraph.Endpoint, tlsPolicy: Telegraph.TLSPolicy? = nil)
  final public var isConnected: Swift.Bool {
    get
  }
  final public var localEndpoint: Telegraph.Endpoint? {
    get
  }
  final public var remoteEndpoint: Telegraph.Endpoint? {
    get
  }
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  final public func setDelegate(_ delegate: any Telegraph.TCPSocketDelegate, queue: Dispatch.DispatchQueue)
  final public func setDelegateQueue(_ queue: Dispatch.DispatchQueue)
  final public func connect(timeout: Foundation.TimeInterval = 30)
  final public func close(when: Telegraph.TCPSocketClose = .immediately)
  final public func read(timeout: Foundation.TimeInterval = -1, tag: Swift.Int = 0)
  final public func read(maxLength: Swift.Int, timeout: Foundation.TimeInterval = -1, tag: Swift.Int = 0)
  final public func write(data: Foundation.Data, timeout: Foundation.TimeInterval = -1, tag: Swift.Int = 0)
  final public func startTLS(config: Telegraph.TLSConfig = TLSConfig())
  @objc deinit
}
extension Telegraph.TCPSocket : Telegraph.ReadStream, Telegraph.WriteStream {
  final public func read(timeout: Foundation.TimeInterval)
  final public func write(data: Foundation.Data, timeout: Foundation.TimeInterval)
  final public func flush()
}
extension Telegraph.TCPSocket : CocoaAsyncSocket.GCDAsyncSocketDelegate {
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didConnectToHost host: Swift.String, port: Swift.UInt16)
  @objc final public func socketDidDisconnect(_ sock: CocoaAsyncSocket.GCDAsyncSocket, withError err: (any Swift.Error)?)
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didRead data: Foundation.Data, withTag tag: Swift.Int)
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didWriteDataWithTag tag: Swift.Int)
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didReceive trust: Security.SecTrust, completionHandler: @escaping (Swift.Bool) -> Swift.Void)
}
public struct TLSConfig {
  public let identity: Telegraph.CertificateIdentity?
  public let certificates: [Telegraph.Certificate]
  public init(serverIdentity: Telegraph.CertificateIdentity, caCertificates: [Telegraph.Certificate])
  public init(clientCertificates: [Telegraph.Certificate] = [])
}
open class TLSPolicy {
  public var commonName: Swift.String?
  public var certificates: [Telegraph.Certificate]
  public init(commonName: Swift.String? = nil, certificates: [Telegraph.Certificate] = [])
  public func evaluate(trust: Security.SecTrust) -> Swift.Bool
  @objc deinit
}
extension Telegraph.TLSPolicy {
  public func evaluateSession(trust: Security.SecTrust?) -> Foundation.URLCredential?
}
extension Swift.UInt8 {
  public static var random: Swift.UInt8 {
    get
  }
}
extension Swift.UInt16 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.UInt32 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.UInt64 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
public struct URI : Swift.Hashable, Swift.Equatable {
  public init(path: Swift.String = "/", query: Swift.String? = nil)
  public init(components: Foundation.URLComponents)
  public init?(url: Foundation.URL)
  public init?(_ string: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Telegraph.URI, b: Telegraph.URI) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension Telegraph.URI {
  public var path: Swift.String {
    get
    set
  }
  public var query: Swift.String? {
    get
    set
  }
  public var queryItems: [Foundation.URLQueryItem]? {
    get
    set
  }
}
extension Telegraph.URI {
  public init(percentEncodedPath: Swift.String, percentEncodedQuery: Swift.String? = nil)
  public var percentEncodedPath: Swift.String {
    get
    set
  }
  public var percentEncodedQuery: Swift.String? {
    get
    set
  }
  public var string: Swift.String {
    get
  }
}
extension Telegraph.URI {
  public static let root: Telegraph.URI
  public func relativePath(from path: Swift.String) -> Swift.String?
}
extension Telegraph.URI : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Foundation.URL {
  public var hasWebSocketScheme: Swift.Bool {
    get
  }
  public var portBasedOnScheme: Swift.Int {
    get
  }
  public var isSchemeSecure: Swift.Bool {
    get
  }
}
extension Foundation.URL {
  public var mimeType: Swift.String {
    get
  }
}
public protocol WebSocket : AnyObject {
  var localEndpoint: Telegraph.Endpoint? { get }
  var remoteEndpoint: Telegraph.Endpoint? { get }
  func close(immediately: Swift.Bool)
  func send(data: Foundation.Data)
  func send(text: Swift.String)
  func send(message: Telegraph.WebSocketMessage)
}
extension Telegraph.WebSocket {
  public func send(data: Foundation.Data)
  public func send(text: Swift.String)
}
public protocol WebSocketClientDelegate : AnyObject {
  func webSocketClient(_ client: Telegraph.WebSocketClient, didConnectToHost host: Swift.String)
  func webSocketClient(_ client: Telegraph.WebSocketClient, didDisconnectWithError error: (any Swift.Error)?)
  func webSocketClient(_ client: Telegraph.WebSocketClient, didReceiveData data: Foundation.Data)
  func webSocketClient(_ client: Telegraph.WebSocketClient, didReceiveText text: Swift.String)
}
open class WebSocketClient : Telegraph.WebSocket {
  final public let url: Foundation.URL
  public var headers: Telegraph.HTTPHeaders
  public var config: Telegraph.WebSocketConfig
  public var tlsPolicy: Telegraph.TLSPolicy?
  weak public var delegate: (any Telegraph.WebSocketClientDelegate)?
  public init(url: Foundation.URL, headers: Telegraph.HTTPHeaders = .empty) throws
  public func connect(timeout: Foundation.TimeInterval = 10)
  public func disconnect()
  public func close(immediately: Swift.Bool)
  public func send(message: Telegraph.WebSocketMessage)
  @objc deinit
}
extension Telegraph.WebSocketClient {
  public var localEndpoint: Telegraph.Endpoint? {
    get
  }
  public var remoteEndpoint: Telegraph.Endpoint? {
    get
  }
}
extension Telegraph.WebSocketClient {
  convenience public init(_ string: Swift.String) throws
  convenience public init(_ string: Swift.String, certificates: [Telegraph.Certificate]) throws
  convenience public init(url: Foundation.URL, certificates: [Telegraph.Certificate]) throws
}
extension Telegraph.WebSocketClient : Telegraph.TCPSocketDelegate {
  public func socketDidOpen(_ socket: Telegraph.TCPSocket)
  public func socketDidClose(_ socket: Telegraph.TCPSocket, error: (any Swift.Error)?)
  public func socketDidRead(_ socket: Telegraph.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  public func socketDidWrite(_ socket: Telegraph.TCPSocket, tag: Swift.Int)
}
extension Telegraph.WebSocketClient : Telegraph.HTTPConnectionDelegate {
  public func connection(_ httpConnection: Telegraph.HTTPConnection, didCloseWithError error: (any Swift.Error)?)
  public func connection(_ httpConnection: Telegraph.HTTPConnection, handleIncomingResponse response: Telegraph.HTTPResponse, error: (any Swift.Error)?)
  public func connection(_ httpConnection: Telegraph.HTTPConnection, handleIncomingRequest request: Telegraph.HTTPRequest, error: (any Swift.Error)?)
  public func connection(_ httpConnection: Telegraph.HTTPConnection, handleUpgradeByRequest request: Telegraph.HTTPRequest)
}
extension Telegraph.WebSocketClient : Telegraph.WebSocketConnectionDelegate {
  public func connection(_ webSocketConnection: Telegraph.WebSocketConnection, didCloseWithError error: (any Swift.Error)?)
  public func connection(_ webSocketConnection: Telegraph.WebSocketConnection, didReceiveMessage message: Telegraph.WebSocketMessage)
  public func connection(_ webSocketConnection: Telegraph.WebSocketConnection, didSendMessage message: Telegraph.WebSocketMessage)
}
public struct WebSocketConfig {
  public var readTimeout: Swift.Double
  public var writeHeaderTimeout: Swift.Double
  public var writePayloadTimeout: Swift.Double
  public var maskMessages: Swift.Bool
  public var pingInterval: Swift.Double
  public var errorHandler: any Telegraph.WebSocketErrorHandler
  public var messageHandler: any Telegraph.WebSocketMessageHandler
  public init()
}
public protocol WebSocketConnectionDelegate : AnyObject {
  func connection(_ webSocketConnection: Telegraph.WebSocketConnection, didReceiveMessage message: Telegraph.WebSocketMessage)
  func connection(_ webSocketConnection: Telegraph.WebSocketConnection, didSendMessage message: Telegraph.WebSocketMessage)
  func connection(_ webSocketConnection: Telegraph.WebSocketConnection, didCloseWithError error: (any Swift.Error)?)
}
open class WebSocketConnection : Telegraph.TCPConnection, Telegraph.WebSocket {
  weak public var delegate: (any Telegraph.WebSocketConnectionDelegate)?
  required public init(socket: Telegraph.TCPSocket, config: Telegraph.WebSocketConfig)
  public func open()
  public func open(data: Foundation.Data?)
  public func close(immediately: Swift.Bool)
  public func send(message: Telegraph.WebSocketMessage)
  @objc deinit
  open var hashValue: Swift.Int {
    get
  }
}
extension Telegraph.WebSocketConnection {
  public var localEndpoint: Telegraph.Endpoint? {
    get
  }
  public var remoteEndpoint: Telegraph.Endpoint? {
    get
  }
}
extension Telegraph.WebSocketConnection : Telegraph.TCPSocketDelegate {
  public func socketDidOpen(_ socket: Telegraph.TCPSocket)
  public func socketDidClose(_ socket: Telegraph.TCPSocket, error: (any Swift.Error)?)
  public func socketDidRead(_ socket: Telegraph.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  public func socketDidWrite(_ socket: Telegraph.TCPSocket, tag: Swift.Int)
}
extension Telegraph.WebSocketConnection : Telegraph.WebSocketParserDelegate {
  public func parser(_ parser: Telegraph.WebSocketParser, didCompleteMessage message: Telegraph.WebSocketMessage)
}
public enum WebSocketError : Swift.Error {
  case invalidMessage
  case invalidOpcode
  case invalidPayloadLength
  case payloadIsNotText
  case payloadTooLarge
  public static func == (a: Telegraph.WebSocketError, b: Telegraph.WebSocketError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Telegraph.WebSocketError {
  public var code: Swift.UInt16 {
    get
  }
}
extension Telegraph.WebSocketError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Telegraph.WebSocketError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class WebSocketErrorDefaultHandler : Telegraph.WebSocketErrorHandler {
  public func incoming(error: any Swift.Error, webSocket: any Telegraph.WebSocket, message: Telegraph.WebSocketMessage?)
  public func outgoing(error: any Swift.Error, webSocket: any Telegraph.WebSocket, message: Telegraph.WebSocketMessage?)
  @objc deinit
}
public protocol WebSocketErrorHandler {
  func incoming(error: any Swift.Error, webSocket: any Telegraph.WebSocket, message: Telegraph.WebSocketMessage?)
  func outgoing(error: any Swift.Error, webSocket: any Telegraph.WebSocket, message: Telegraph.WebSocketMessage?)
}
open class WebSocketMessage {
  public var finBit: Swift.Bool
  public var maskBit: Swift.Bool
  public var opcode: Telegraph.WebSocketOpcode
  public var payload: Telegraph.WebSocketPayload
  public init(opcode: Telegraph.WebSocketOpcode = .connectionClose, payload: Telegraph.WebSocketPayload = .none)
  @objc deinit
}
public enum WebSocketOpcode : Swift.UInt8 {
  case continuationFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum WebSocketPayload {
  case none
  case binary(Foundation.Data)
  case text(Swift.String)
  case close(code: Swift.UInt16, reason: Swift.String)
}
public struct WebSocketMasks {
}
extension Telegraph.WebSocketMessage {
  convenience public init(closeCode: Swift.UInt16, reason: Swift.String = "")
  convenience public init(error: Telegraph.WebSocketError)
  convenience public init(data: Foundation.Data)
  convenience public init(text: Swift.String)
}
extension Telegraph.WebSocketMessage {
  public func generateMask() -> [Swift.UInt8]
}
extension Telegraph.WebSocketMessage : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Telegraph.WebSocketMessage {
  public func write(to stream: any Telegraph.WriteStream, headerTimeout: Foundation.TimeInterval, payloadTimeout: Foundation.TimeInterval)
}
extension Telegraph.WebSocketPayload {
  public var data: Foundation.Data? {
    get
  }
}
@_hasMissingDesignatedInitializers public class WebSocketMessageDefaultHandler : Telegraph.WebSocketMessageHandler {
  public func incoming(message: Telegraph.WebSocketMessage, from webSocket: any Telegraph.WebSocket) throws
  public func outgoing(message: Telegraph.WebSocketMessage, to webSocket: any Telegraph.WebSocket) throws
  @objc deinit
}
public protocol WebSocketMessageHandler {
  func incoming(message: Telegraph.WebSocketMessage, from webSocket: any Telegraph.WebSocket) throws
  func outgoing(message: Telegraph.WebSocketMessage, to webSocket: any Telegraph.WebSocket) throws
}
public protocol WebSocketParserDelegate : AnyObject {
  func parser(_ parser: Telegraph.WebSocketParser, didCompleteMessage message: Telegraph.WebSocketMessage)
}
public class WebSocketParser {
  final public let maxPayloadLength: Swift.UInt64
  weak public var delegate: (any Telegraph.WebSocketParserDelegate)?
  public var message: Telegraph.WebSocketMessage {
    get
  }
  public var maskingKey: [Swift.UInt8] {
    get
  }
  public var payload: Foundation.Data {
    get
  }
  public var nextPart: Telegraph.WebSocketParser.Part {
    get
  }
  public var bytesParsed: Swift.Int {
    get
  }
  public var payloadLength: Swift.UInt64 {
    get
  }
  public enum Part {
    case finAndOpcode
    case maskAndPayloadLength
    case extendedPayloadLength16(byteNo: Swift.Int)
    case extendedPayloadLength64(byteNo: Swift.Int)
    case maskingKey(byteNo: Swift.Int)
    case payload
    case endOfMessage
  }
  public init(maxPayloadLength: Swift.Int = 10_485_760)
  public func parse(data: Foundation.Data) throws
  public func reset()
  @objc deinit
}
@available(*, deprecated, message: "these specific errors are no longer thrown")
extension Telegraph.HTTPRouteError : Swift.Equatable {}
@available(*, deprecated, message: "these specific errors are no longer thrown")
extension Telegraph.HTTPRouteError : Swift.Hashable {}
extension Telegraph.TCPSocketClose : Swift.Equatable {}
extension Telegraph.TCPSocketClose : Swift.Hashable {}
extension Telegraph.WebSocketError : Swift.Equatable {}
extension Telegraph.WebSocketError : Swift.Hashable {}
extension Telegraph.WebSocketOpcode : Swift.Equatable {}
extension Telegraph.WebSocketOpcode : Swift.Hashable {}
extension Telegraph.WebSocketOpcode : Swift.RawRepresentable {}
