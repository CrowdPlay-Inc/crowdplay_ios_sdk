// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 6.2.3 effective-5.10 (swiftlang-6.2.3.3.21 clang-1700.6.3.2)
// swift-module-flags: -target arm64-apple-ios16.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -enable-experimental-feature DebugDescriptionMacro -enable-bare-slash-regex -module-name patrol
// swift-module-flags-ignorable: -no-verify-emitted-module-interface -formal-cxx-interoperability-mode=off -interface-compiler-version 6.2.3
import CocoaAsyncSocket
import CommonCrypto
import Flutter
import Foundation
import MobileCoreServices
import Security
import Swift
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_exported import patrol
extension Swift.Array {
  #if compiler(>=5.3) && $NonescapableTypes
  public func first<T>(ofType: T.Type) -> T?
  #endif
  public func filter<T>(ofType: T.Type) -> [T]
}
extension patrol.Selector {
  public func toTextFieldNSPredicate() -> Foundation.NSPredicate
  public func toNSPredicate() -> Foundation.NSPredicate
}
open class Certificate : Swift.RawRepresentable {
  final public let rawValue: Security.SecCertificate
  required public init(rawValue: Security.SecCertificate)
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init?(derData: Foundation.Data)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init?(derURL: Foundation.URL)
  #endif
  public typealias RawValue = Security.SecCertificate
  @objc deinit
}
extension patrol.Certificate {
  #if compiler(>=5.3) && $NonescapableTypes
  public var commonName: Swift.String? {
    get
  }
  #endif
}
extension patrol.Certificate {
  convenience public init(fromKeychain label: Swift.String) throws
  public func addToKeychain(label: Swift.String) throws
  public static func removeFromKeychain(label: Swift.String) throws
}
open class CertificateIdentity : Swift.RawRepresentable {
  final public let rawValue: Security.SecIdentity
  required public init(rawValue: Security.SecIdentity)
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init?(p12Data: Foundation.Data, passphrase: Swift.String)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init?(p12URL: Foundation.URL, passphrase: Swift.String)
  #endif
  public typealias RawValue = Security.SecIdentity
  @objc deinit
}
extension patrol.CertificateIdentity {
  convenience public init(fromKeychain label: Swift.String) throws
  public func addToKeychain(label: Swift.String) throws
  public static func removeFromKeychain(label: Swift.String) throws
}
extension patrol.CertificateIdentity {
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init?(p12Data: Foundation.Data)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  convenience public init?(p12URL: Foundation.URL)
  #endif
}
extension patrol.HTTPConfig {
  public static var clientDefault: patrol.HTTPConfig {
    get
  }
}
extension patrol.WebSocketConfig {
  public static var clientDefault: patrol.WebSocketConfig {
    get
  }
}
public enum GroupEntryType : Swift.String, Swift.Codable {
  case group
  case test
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RunDartTestResponseResult : Swift.String, Swift.Codable {
  case success
  case skipped
  case failure
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum KeyboardBehavior : Swift.String, Swift.Codable {
  case showAndDismiss
  case alternative
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum HandlePermissionRequestCode : Swift.String, Swift.Codable {
  case whileUsing
  case onlyThisTime
  case denied
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum SetLocationAccuracyRequestLocationAccuracy : Swift.String, Swift.Codable {
  case coarse
  case fine
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum IOSElementType : Swift.String, Swift.Codable {
  case any
  case other
  case application
  case group
  case window
  case sheet
  case drawer
  case alert
  case dialog
  case button
  case radioButton
  case radioGroup
  case checkBox
  case disclosureTriangle
  case popUpButton
  case comboBox
  case menuButton
  case toolbarButton
  case popover
  case keyboard
  case key
  case navigationBar
  case tabBar
  case tabGroup
  case toolbar
  case statusBar
  case table
  case tableRow
  case tableColumn
  case outline
  case outlineRow
  case browser
  case collectionView
  case slider
  case pageIndicator
  case progressIndicator
  case activityIndicator
  case segmentedControl
  case picker
  case pickerWheel
  case switch_
  case toggle
  case link
  case image
  case icon
  case searchField
  case scrollView
  case scrollBar
  case staticText
  case textField
  case secureTextField
  case datePicker
  case textView
  case menu
  case menuItem
  case menuBar
  case menuBarItem
  case map
  case webView
  case incrementArrow
  case decrementArrow
  case timeline
  case ratingIndicator
  case valueIndicator
  case splitGroup
  case splitter
  case relevanceIndicator
  case colorWell
  case helpTag
  case matte
  case dockItem
  case ruler
  case rulerMarker
  case grid
  case levelIndicator
  case cell
  case layoutArea
  case layoutItem
  case handle
  case stepper
  case tab
  case touchBar
  case statusItem
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.String)
  #endif
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct DartGroupEntry : Swift.Codable {
  public var name: Swift.String
  public var type: patrol.GroupEntryType
  public var entries: [patrol.DartGroupEntry]
  public var skip: Swift.Bool
  public var tags: [Swift.String]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ListDartTestsResponse : Swift.Codable {
  public var group: patrol.DartGroupEntry
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RunDartTestRequest : Swift.Codable {
  public var name: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct RunDartTestResponse : Swift.Codable {
  public var result: patrol.RunDartTestResponseResult
  public var details: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct ConfigureRequest : Swift.Codable {
  public var findTimeoutMillis: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct OpenAppRequest : Swift.Codable {
  public var appId: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct OpenQuickSettingsRequest : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct OpenUrlRequest : Swift.Codable {
  public var url: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AndroidSelector : Swift.Codable {
  public var className: Swift.String?
  public var isCheckable: Swift.Bool?
  public var isChecked: Swift.Bool?
  public var isClickable: Swift.Bool?
  public var isEnabled: Swift.Bool?
  public var isFocusable: Swift.Bool?
  public var isFocused: Swift.Bool?
  public var isLongClickable: Swift.Bool?
  public var isScrollable: Swift.Bool?
  public var isSelected: Swift.Bool?
  public var applicationPackage: Swift.String?
  public var contentDescription: Swift.String?
  public var contentDescriptionStartsWith: Swift.String?
  public var contentDescriptionContains: Swift.String?
  public var text: Swift.String?
  public var textStartsWith: Swift.String?
  public var textContains: Swift.String?
  public var resourceName: Swift.String?
  public var instance: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct IOSSelector : Swift.Codable {
  public var value: Swift.String?
  public var instance: Swift.Int?
  public var elementType: patrol.IOSElementType?
  public var identifier: Swift.String?
  public var label: Swift.String?
  public var labelStartsWith: Swift.String?
  public var labelContains: Swift.String?
  public var title: Swift.String?
  public var titleStartsWith: Swift.String?
  public var titleContains: Swift.String?
  public var hasFocus: Swift.Bool?
  public var isEnabled: Swift.Bool?
  public var isSelected: Swift.Bool?
  public var placeholderValue: Swift.String?
  public var placeholderValueStartsWith: Swift.String?
  public var placeholderValueContains: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Selector : Swift.Codable {
  public var text: Swift.String?
  public var textStartsWith: Swift.String?
  public var textContains: Swift.String?
  public var className: Swift.String?
  public var contentDescription: Swift.String?
  public var contentDescriptionStartsWith: Swift.String?
  public var contentDescriptionContains: Swift.String?
  public var resourceId: Swift.String?
  public var instance: Swift.Int?
  public var enabled: Swift.Bool?
  public var focused: Swift.Bool?
  public var pkg: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNativeViewsRequest : Swift.Codable {
  public var selector: patrol.Selector?
  public var androidSelector: patrol.AndroidSelector?
  public var iosSelector: patrol.IOSSelector?
  public var appId: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNativeUITreeRequest : Swift.Codable {
  public var iosInstalledApps: [Swift.String]?
  public var useNativeViewHierarchy: Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNativeUITreeRespone : Swift.Codable {
  public var iOSroots: [patrol.IOSNativeView]
  public var androidRoots: [patrol.AndroidNativeView]
  public var roots: [patrol.NativeView]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct AndroidNativeView : Swift.Codable {
  public var resourceName: Swift.String?
  public var text: Swift.String?
  public var className: Swift.String?
  public var contentDescription: Swift.String?
  public var applicationPackage: Swift.String?
  public var childCount: Swift.Int
  public var isCheckable: Swift.Bool
  public var isChecked: Swift.Bool
  public var isClickable: Swift.Bool
  public var isEnabled: Swift.Bool
  public var isFocusable: Swift.Bool
  public var isFocused: Swift.Bool
  public var isLongClickable: Swift.Bool
  public var isScrollable: Swift.Bool
  public var isSelected: Swift.Bool
  public var visibleBounds: patrol.Rectangle
  public var visibleCenter: patrol.Point2D
  public var children: [patrol.AndroidNativeView]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct IOSNativeView : Swift.Codable {
  public var children: [patrol.IOSNativeView]
  public var elementType: patrol.IOSElementType
  public var identifier: Swift.String
  public var label: Swift.String
  public var title: Swift.String
  public var hasFocus: Swift.Bool
  public var isEnabled: Swift.Bool
  public var isSelected: Swift.Bool
  public var frame: patrol.Rectangle
  public var placeholderValue: Swift.String?
  public var value: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Rectangle : Swift.Codable {
  public var minX: Swift.Double
  public var minY: Swift.Double
  public var maxX: Swift.Double
  public var maxY: Swift.Double
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Point2D : Swift.Codable {
  public var x: Swift.Double
  public var y: Swift.Double
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct NativeView : Swift.Codable {
  public var className: Swift.String?
  public var text: Swift.String?
  public var contentDescription: Swift.String?
  public var focused: Swift.Bool
  public var enabled: Swift.Bool
  public var childCount: Swift.Int?
  public var resourceName: Swift.String?
  public var applicationPackage: Swift.String?
  public var children: [patrol.NativeView]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNativeViewsResponse : Swift.Codable {
  public var nativeViews: [patrol.NativeView]
  public var iosNativeViews: [patrol.IOSNativeView]
  public var androidNativeViews: [patrol.AndroidNativeView]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TapRequest : Swift.Codable {
  public var selector: patrol.Selector?
  public var androidSelector: patrol.AndroidSelector?
  public var iosSelector: patrol.IOSSelector?
  public var appId: Swift.String
  public var timeoutMillis: Swift.Int?
  public var delayBetweenTapsMillis: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TapAtRequest : Swift.Codable {
  public var x: Swift.Double
  public var y: Swift.Double
  public var appId: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct EnterTextRequest : Swift.Codable {
  public var data: Swift.String
  public var appId: Swift.String
  public var index: Swift.Int?
  public var selector: patrol.Selector?
  public var androidSelector: patrol.AndroidSelector?
  public var iosSelector: patrol.IOSSelector?
  public var keyboardBehavior: patrol.KeyboardBehavior
  public var timeoutMillis: Swift.Int?
  public var dx: Swift.Double
  public var dy: Swift.Double
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct SwipeRequest : Swift.Codable {
  public var appId: Swift.String
  public var startX: Swift.Double
  public var startY: Swift.Double
  public var endX: Swift.Double
  public var endY: Swift.Double
  public var steps: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct WaitUntilVisibleRequest : Swift.Codable {
  public var selector: patrol.Selector?
  public var androidSelector: patrol.AndroidSelector?
  public var iosSelector: patrol.IOSSelector?
  public var appId: Swift.String
  public var timeoutMillis: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct DarkModeRequest : Swift.Codable {
  public var appId: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct Notification : Swift.Codable {
  public var appName: Swift.String?
  public var title: Swift.String
  public var content: Swift.String
  public var raw: Swift.String?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNotificationsResponse : Swift.Codable {
  public var notifications: [patrol.Notification]
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct GetNotificationsRequest : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct TapOnNotificationRequest : Swift.Codable {
  public var index: Swift.Int?
  public var selector: patrol.Selector?
  public var androidSelector: patrol.AndroidSelector?
  public var iosSelector: patrol.IOSSelector?
  public var timeoutMillis: Swift.Int?
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PermissionDialogVisibleResponse : Swift.Codable {
  public var visible: Swift.Bool
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct PermissionDialogVisibleRequest : Swift.Codable {
  public var timeoutMillis: Swift.Int
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct HandlePermissionRequest : Swift.Codable {
  public var code: patrol.HandlePermissionRequestCode
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct SetLocationAccuracyRequest : Swift.Codable {
  public var locationAccuracy: patrol.SetLocationAccuracyRequestLocationAccuracy
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension Foundation.Data {
  public static let crlf: Foundation.Data
  public init(randomNumberOfBytes count: Swift.Int)
  public func hexEncodedString() -> Swift.String
  public mutating func mask(with maskBytes: [Swift.UInt8])
}
final public class DataStream {
  final public var position: Swift.Int {
    get
  }
  public init(data: Foundation.Data = Data())
  final public var hasBytesAvailable: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public func read() -> Swift.UInt8?
  #endif
  final public func read(count: Swift.Int) -> Foundation.Data
  final public func readToEnd() -> Foundation.Data
  @objc deinit
}
extension Foundation.DateFormatter {
  @available(*, deprecated, renamed: "rfc1123")
  public var rfc7231: Foundation.DateFormatter {
    get
  }
}
extension patrol.DispatchTimer {
  @available(*, deprecated, message: "no longer supported, use start(at:) to run the timer at a later time")
  public static func run(after: Foundation.TimeInterval, interval: Foundation.TimeInterval = 0, queue: Dispatch.DispatchQueue, execute block: @escaping () -> Swift.Void) -> patrol.DispatchTimer
  @available(*, deprecated, message: "no longer supported, use start(at:) to run the timer at a later time")
  final public func start(after: Foundation.TimeInterval)
}
extension Foundation.FileManager {
  @available(*, deprecated, message: "use <url>.mimeType")
  public func mimeType(of url: Foundation.URL) -> Swift.String
}
extension patrol.HTTPHeaderName {
  @available(*, deprecated, message: "construct lower cased names manually")
  public static var forceLowerCased: Swift.Bool
}
extension patrol.HTTPMethod {
  @available(*, deprecated, renamed: "GET")
  public static var get: patrol.HTTPMethod
  @available(*, deprecated, renamed: "HEAD")
  public static var head: patrol.HTTPMethod
  @available(*, deprecated, renamed: "DELETE")
  public static var delete: patrol.HTTPMethod
  @available(*, deprecated, renamed: "OPTIONS")
  public static var options: patrol.HTTPMethod
  @available(*, deprecated, renamed: "POST")
  public static var post: patrol.HTTPMethod
  @available(*, deprecated, renamed: "PUT")
  public static var put: patrol.HTTPMethod
  @available(*, deprecated, renamed: "init(name:)")
  public init(rawValue: Swift.String)
  @available(*, deprecated, renamed: "init(name:)")
  public static func method(_ name: Swift.String) -> patrol.HTTPMethod
}
@available(*, deprecated, message: "these specific errors are no longer thrown")
public enum HTTPRouteError : Swift.Error {
  case invalidURI
  public static func == (a: patrol.HTTPRouteError, b: patrol.HTTPRouteError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.HTTPStatus {
  @available(*, deprecated, message: "return nil from your handler (this status is used by Nginx, not part of the spec)")
  public static let noResponse: patrol.HTTPStatus
}
@available(*, deprecated, message: "use HTTPStatus, for example .ok or .notFound")
public typealias HTTPStatusCode = patrol.HTTPStatus
extension patrol.HTTPResponse {
  @available(*, deprecated, message: "use DateFormatter.rfc1123 or Date's rfc1123 variable")
  public static let dateFormatter: Foundation.DateFormatter
  @available(*, deprecated, renamed: "init(status:data:)")
  convenience public init(_ status: patrol.HTTPStatus = .ok, data: Foundation.Data)
  @available(*, deprecated, message: "use keepAlive instead, this setter only handles true properly")
  public var closeAfterWrite: Swift.Bool {
    get
    set
  }
}
extension patrol.HTTPVersion {
  @available(*, deprecated, renamed: "init(major:minor:)")
  public init(_ major: Swift.UInt, _ minor: Swift.UInt)
}
extension patrol.Server {
  @available(*, deprecated, renamed: "start(port:)")
  public func start(onPort port: Swift.UInt16) throws
  #if compiler(>=5.3) && $NonescapableTypes
  @available(*, deprecated, renamed: "start(port:interface:)")
  public func start(onInterface interface: Swift.String?, port: Swift.UInt16 = 0) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(swift, obsoleted: 5, renamed: "responseFor(request:)")
  public func handleIncoming(request: patrol.HTTPRequest) throws -> patrol.HTTPResponse?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @available(swift, obsoleted: 5, renamed: "responseFor(error:)")
  public func handleIncoming(error: any Swift.Error) throws -> patrol.HTTPResponse?
  #endif
}
@_hasMissingDesignatedInitializers final public class DispatchTimer {
  @objc deinit
}
extension patrol.DispatchTimer {
  public static func run(interval: Foundation.TimeInterval, queue: Dispatch.DispatchQueue, execute block: @escaping () -> Swift.Void) -> patrol.DispatchTimer
  public static func run(at: Foundation.Date, interval: Foundation.TimeInterval = 0, queue: Dispatch.DispatchQueue, execute block: @escaping () -> Swift.Void) -> patrol.DispatchTimer
}
public struct Endpoint : Swift.Hashable {
  public typealias Host = Swift.String
  public typealias Port = Swift.Int
  public var host: patrol.Endpoint.Host
  public var port: patrol.Endpoint.Port
  public init(host: patrol.Endpoint.Host, port: patrol.Endpoint.Port)
  public static func == (a: patrol.Endpoint, b: patrol.Endpoint) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.Endpoint {
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(url: Foundation.URL)
  #endif
  public init(host: patrol.Endpoint.Host, port: Swift.UInt16)
}
extension Foundation.FileManager {
  public func mimeType(pathExtension: Swift.String) -> Swift.String
}
public struct HTTPConfig {
  public var readTimeout: Swift.Double
  public var writeHeaderTimeout: Swift.Double
  public var writeBodyTimeout: Swift.Double
  public var errorHandler: any patrol.HTTPErrorHandler
  public var requestHandlers: [any patrol.HTTPRequestHandler] {
    get
    set
  }
  public init(requestHandlers: [any patrol.HTTPRequestHandler])
}
public protocol HTTPConnectionDelegate : AnyObject {
  #if compiler(>=5.3) && $NonescapableTypes
  func connection(_ httpConnection: patrol.HTTPConnection, didCloseWithError error: (any Swift.Error)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingRequest request: patrol.HTTPRequest, error: (any Swift.Error)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingResponse response: patrol.HTTPResponse, error: (any Swift.Error)?)
  #endif
  func connection(_ httpConnection: patrol.HTTPConnection, handleUpgradeByRequest request: patrol.HTTPRequest)
}
public class HTTPConnection : patrol.TCPConnection {
  weak public var delegate: (any patrol.HTTPConnectionDelegate)?
  required public init(socket: patrol.TCPSocket, config: patrol.HTTPConfig)
  public func open()
  public func close(immediately: Swift.Bool)
  #if compiler(>=5.3) && $NonescapableTypes
  public func upgrade() -> (patrol.TCPSocket, Foundation.Data?)
  #endif
  public func send(data: Foundation.Data, timeout: Foundation.TimeInterval)
  public func send(request: patrol.HTTPRequest)
  public func send(response: patrol.HTTPResponse, toRequest request: patrol.HTTPRequest)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.HTTPConnection {
  #if compiler(>=5.3) && $NonescapableTypes
  public var localEndpoint: patrol.Endpoint? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var remoteEndpoint: patrol.Endpoint? {
    get
  }
  #endif
}
extension patrol.HTTPConnection : patrol.TCPSocketDelegate {
  public func socketDidOpen(_ socket: patrol.TCPSocket)
  #if compiler(>=5.3) && $NonescapableTypes
  public func socketDidClose(_ socket: patrol.TCPSocket, error: (any Swift.Error)?)
  #endif
  public func socketDidRead(_ socket: patrol.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  public func socketDidWrite(_ socket: patrol.TCPSocket, tag: Swift.Int)
}
public enum HTTPError : Swift.Error {
  case unexpectedStreamEnd
  case connectionShouldBeClosed
  case protocolNotSupported
  case invalidContentLength
  case invalidHeader
  case invalidRequest
  case invalidMethod
  case invalidURI
  case invalidVersion
  case headerOverflow
  case parseFailed(code: Swift.Int)
}
extension patrol.HTTPError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.HTTPError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
@_hasMissingDesignatedInitializers public class HTTPErrorDefaultHandler : patrol.HTTPErrorHandler {
  #if compiler(>=5.3) && $NonescapableTypes
  public func respond(to error: any Swift.Error) -> patrol.HTTPResponse?
  #endif
  @objc deinit
}
public protocol HTTPErrorHandler {
  #if compiler(>=5.3) && $NonescapableTypes
  func respond(to error: any Swift.Error) -> patrol.HTTPResponse?
  #endif
}
public typealias HTTPHeaders = [patrol.HTTPHeaderName : Swift.String]
public struct HTTPHeaderName : Swift.Hashable {
  public static func == (lhs: patrol.HTTPHeaderName, rhs: patrol.HTTPHeaderName) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.HTTPHeaderName : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.HTTPHeaderName : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension Swift.Dictionary where Key == patrol.HTTPHeaderName, Value == Swift.String {
  public static var empty: patrol.HTTPHeaders {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public subscript(key: Swift.String) -> Swift.String? {
    get
    set
  }
  #endif
}
extension patrol.HTTPHeaderName {
  public static let accept: patrol.HTTPHeaderName
  public static let acceptCharset: patrol.HTTPHeaderName
  public static let acceptEncoding: patrol.HTTPHeaderName
  public static let acceptLanguage: patrol.HTTPHeaderName
  public static let acceptRanges: patrol.HTTPHeaderName
  public static let accessControlAllowOrigin: patrol.HTTPHeaderName
  public static let accessControlAllowHeaders: patrol.HTTPHeaderName
  public static let accessControlAllowMethods: patrol.HTTPHeaderName
  public static let accessControlMaxAge: patrol.HTTPHeaderName
  public static let age: patrol.HTTPHeaderName
  public static let allow: patrol.HTTPHeaderName
  public static let authorization: patrol.HTTPHeaderName
  public static let cacheControl: patrol.HTTPHeaderName
  public static let connection: patrol.HTTPHeaderName
  public static let cookie: patrol.HTTPHeaderName
  public static let contentDisposition: patrol.HTTPHeaderName
  public static let contentEncoding: patrol.HTTPHeaderName
  public static let contentLanguage: patrol.HTTPHeaderName
  public static let contentLength: patrol.HTTPHeaderName
  public static let contentRange: patrol.HTTPHeaderName
  public static let contentType: patrol.HTTPHeaderName
  public static let date: patrol.HTTPHeaderName
  public static let eTag: patrol.HTTPHeaderName
  public static let expect: patrol.HTTPHeaderName
  public static let expires: patrol.HTTPHeaderName
  public static let forwarded: patrol.HTTPHeaderName
  public static let host: patrol.HTTPHeaderName
  public static let ifModifiedSince: patrol.HTTPHeaderName
  public static let lastModified: patrol.HTTPHeaderName
  public static let location: patrol.HTTPHeaderName
  public static let origin: patrol.HTTPHeaderName
  public static let pragma: patrol.HTTPHeaderName
  public static let range: patrol.HTTPHeaderName
  public static let referer: patrol.HTTPHeaderName
  public static let refresh: patrol.HTTPHeaderName
  public static let server: patrol.HTTPHeaderName
  public static let setCookie: patrol.HTTPHeaderName
  public static let strictTransportSecurity: patrol.HTTPHeaderName
  public static let transferEncoding: patrol.HTTPHeaderName
  public static let userAgent: patrol.HTTPHeaderName
  public static let upgrade: patrol.HTTPHeaderName
}
extension Swift.Dictionary where Key == patrol.HTTPHeaderName, Value == Swift.String {
  #if compiler(>=5.3) && $NonescapableTypes
  public var accept: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var acceptCharset: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var acceptEncoding: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var acceptLanguage: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var acceptRanges: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var accessControlAllowOrigin: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var accessControlAllowHeaders: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var accessControlAllowMethods: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var accessControlMaxAge: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var age: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var allow: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var authorization: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var cacheControl: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var connection: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var cookie: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var contentDisposition: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var contentEncoding: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var contentLanguage: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var contentLength: Swift.Int? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var contentRange: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var contentType: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var date: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var eTag: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var expect: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var expires: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var forwarded: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var host: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var ifModifiedSince: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var lastModified: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var location: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var origin: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var pragma: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var range: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var referer: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var refresh: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var server: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var setCookie: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var strictTransportSecurity: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var transferEncoding: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var userAgent: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var upgrade: Swift.String? {
    get
    set
  }
  #endif
}
extension patrol.HTTPHeaderName {
  public static let webSocketAccept: patrol.HTTPHeaderName
  public static let webSocketKey: patrol.HTTPHeaderName
  public static let webSocketProtocol: patrol.HTTPHeaderName
  public static let webSocketVersion: patrol.HTTPHeaderName
}
extension Swift.Dictionary where Key == patrol.HTTPHeaderName, Value == Swift.String {
  #if compiler(>=5.3) && $NonescapableTypes
  public var webSocketAccept: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var webSocketKey: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var webSocketProtocol: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var webSocketVersion: Swift.String? {
    get
    set
  }
  #endif
}
open class HTTPMessage {
  public var version: patrol.HTTPVersion
  public var headers: patrol.HTTPHeaders
  public var body: Foundation.Data
  public init(version: patrol.HTTPVersion = .default, headers: patrol.HTTPHeaders = .empty, body: Foundation.Data = Data())
  open func prepareForWrite()
  public func write(to stream: any patrol.WriteStream, headerTimeout: Foundation.TimeInterval, bodyTimeout: Foundation.TimeInterval)
  open func writeHeader(to stream: any patrol.WriteStream, timeout: Foundation.TimeInterval)
  open func writeBody(to stream: any patrol.WriteStream, timeout: Foundation.TimeInterval)
  @objc deinit
}
extension patrol.HTTPMessage {
  public var keepAlive: Swift.Bool {
    get
  }
  public var isConnectionUpgrade: Swift.Bool {
    get
  }
}
extension patrol.HTTPMessage {
  public static let webSocketMagicGUID: Swift.String
  public static let webSocketProtocol: Swift.String
  public static let webSocketVersion: Swift.String
  public var isWebSocketUpgrade: Swift.Bool {
    get
  }
}
extension patrol.HTTPRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func webSocketHandshake(host: Swift.String, port: Swift.Int = 80, protocolName: Swift.String? = nil) -> patrol.HTTPRequest
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func webSocketHandshake(host: Swift.String, port: Swift.Int = 80, protocolName: Swift.String? = nil)
  #endif
}
extension patrol.HTTPResponse {
  #if compiler(>=5.3) && $NonescapableTypes
  public static func webSocketHandshake(key: Swift.String, protocolName: Swift.String? = nil) -> patrol.HTTPResponse
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func webSocketHandshake(key: Swift.String, protocolName: Swift.String? = nil)
  #endif
  public var isWebSocketHandshake: Swift.Bool {
    get
  }
}
public struct HTTPMethod : Swift.Hashable {
  public let name: Swift.String
  public static func == (a: patrol.HTTPMethod, b: patrol.HTTPMethod) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.HTTPMethod {
  public static let GET: patrol.HTTPMethod
  public static let HEAD: patrol.HTTPMethod
  public static let DELETE: patrol.HTTPMethod
  public static let POST: patrol.HTTPMethod
  public static let PUT: patrol.HTTPMethod
  public static let OPTIONS: patrol.HTTPMethod
  public static let CONNECT: patrol.HTTPMethod
  public static let TRACE: patrol.HTTPMethod
  public static let PATCH: patrol.HTTPMethod
}
extension patrol.HTTPMethod : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.HTTPMethod : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral string: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
final public class HTTPParser {
  final public var message: patrol.HTTPMessage? {
    get
  }
  final public var isMessageComplete: Swift.Bool {
    get
  }
  final public var isUpgradeDetected: Swift.Bool {
    get
  }
  public init()
  @discardableResult
  final public func parse(data: Foundation.Data) throws -> Swift.Int
  final public func reset()
  @objc deinit
}
open class HTTPRequest : patrol.HTTPMessage {
  public typealias Params = [Swift.String : Swift.String]
  public var method: patrol.HTTPMethod
  public var uri: patrol.URI
  public var params: patrol.HTTPRequest.Params
  public init(_ method: patrol.HTTPMethod = .GET, uri: patrol.URI = .root, version: patrol.HTTPVersion = .default, headers: patrol.HTTPHeaders = .empty, body: Foundation.Data = Data())
  override open func prepareForWrite()
  @objc deinit
}
extension patrol.HTTPRequest : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.HTTPRequest {
  #if compiler(>=5.3) && $NonescapableTypes
  public func setHostHeader(host: Swift.String?, port: Swift.Int? = nil)
  #endif
}
public protocol HTTPRequestHandler {
  #if compiler(>=5.3) && $NonescapableTypes
  func respond(to request: patrol.HTTPRequest, nextHandler: (patrol.HTTPRequest) throws -> patrol.HTTPResponse?) throws -> patrol.HTTPResponse?
  #endif
}
extension patrol.HTTPRequest {
  public typealias Handler = (patrol.HTTPRequest) throws -> patrol.HTTPResponse?
}
open class HTTPResponse : patrol.HTTPMessage {
  public typealias Handler = (patrol.HTTPResponse, any Swift.Error) -> Swift.Void
  public var status: patrol.HTTPStatus
  public init(_ status: patrol.HTTPStatus = .ok, version: patrol.HTTPVersion = .default, headers: patrol.HTTPHeaders = .empty, body: Foundation.Data = Data(), isComplete: Swift.Bool = true)
  override open func prepareForWrite()
  @objc deinit
}
extension patrol.HTTPResponse {
  convenience public init(_ status: patrol.HTTPStatus = .ok, headers: patrol.HTTPHeaders = .empty, content: Swift.String)
  convenience public init(_ status: patrol.HTTPStatus = .internalServerError, headers: patrol.HTTPHeaders = .empty, error: any Swift.Error)
}
extension patrol.HTTPResponse : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPRoute {
  public let methods: Swift.Set<patrol.HTTPMethod>?
  public let handler: patrol.HTTPRequest.Handler
  public let regex: patrol.Regex?
  public let params: [patrol.HTTPRequest.Params.Key]
  #if compiler(>=5.3) && $NonescapableTypes
  public init(methods: Swift.Set<patrol.HTTPMethod>? = nil, regex pattern: Swift.String? = nil, handler: @escaping patrol.HTTPRequest.Handler) throws
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init(methods: Swift.Set<patrol.HTTPMethod>? = nil, uri: Swift.String, handler: @escaping patrol.HTTPRequest.Handler) throws
  #endif
}
extension patrol.HTTPRoute {
  public func canHandle(method: patrol.HTTPMethod) -> Swift.Bool
  public func canHandle(path: Swift.String) -> (Swift.Bool, patrol.HTTPRequest.Params)
}
@_hasMissingDesignatedInitializers open class HTTPRouteHandler : patrol.HTTPRequestHandler {
  public var routes: [patrol.HTTPRoute]
  public var implicitHeadRequests: Swift.Bool
  #if compiler(>=5.3) && $NonescapableTypes
  open func respond(to request: patrol.HTTPRequest, nextHandler: (patrol.HTTPRequest) throws -> patrol.HTTPResponse?) throws -> patrol.HTTPResponse?
  #endif
  @objc deinit
}
public struct HTTPStatus : Swift.Hashable {
  public let code: Swift.Int
  public let phrase: Swift.String
  public let strict: Swift.Bool
  public init(code: Swift.Int, phrase: Swift.String, strict: Swift.Bool = false)
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.HTTPStatus {
  public var isInformational: Swift.Bool {
    get
  }
  public var isSuccess: Swift.Bool {
    get
  }
  public var isRedirection: Swift.Bool {
    get
  }
  public var isClientError: Swift.Bool {
    get
  }
  public var isServerError: Swift.Bool {
    get
  }
  public var supportsBody: Swift.Bool {
    get
  }
}
extension patrol.HTTPStatus {
  public static func == (lhs: patrol.HTTPStatus, rhs: patrol.HTTPStatus) -> Swift.Bool
}
extension patrol.HTTPStatus : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.HTTPStatus {
  public static let `continue`: patrol.HTTPStatus
  public static let switchingProtocols: patrol.HTTPStatus
  public static let processing: patrol.HTTPStatus
}
extension patrol.HTTPStatus {
  public static let ok: patrol.HTTPStatus
  public static let created: patrol.HTTPStatus
  public static let accepted: patrol.HTTPStatus
  public static let nonAuthoritativeInformation: patrol.HTTPStatus
  public static let noContent: patrol.HTTPStatus
  public static let resetContent: patrol.HTTPStatus
  public static let partialContent: patrol.HTTPStatus
  public static let multiStatus: patrol.HTTPStatus
  public static let alreadyReported: patrol.HTTPStatus
  public static let imUsed: patrol.HTTPStatus
}
extension patrol.HTTPStatus {
  public static let multipleChoices: patrol.HTTPStatus
  public static let movedPermanently: patrol.HTTPStatus
  public static let found: patrol.HTTPStatus
  public static let seeOther: patrol.HTTPStatus
  public static let notModified: patrol.HTTPStatus
  public static let useProxy: patrol.HTTPStatus
  public static let temporaryRedirect: patrol.HTTPStatus
  public static let permanentRedirect: patrol.HTTPStatus
}
extension patrol.HTTPStatus {
  public static let badRequest: patrol.HTTPStatus
  public static let unauthorized: patrol.HTTPStatus
  public static let paymentRequired: patrol.HTTPStatus
  public static let forbidden: patrol.HTTPStatus
  public static let notFound: patrol.HTTPStatus
  public static let methodNotAllowed: patrol.HTTPStatus
  public static let notAcceptable: patrol.HTTPStatus
  public static let proxyAuthenticationRequired: patrol.HTTPStatus
  public static let requestTimeout: patrol.HTTPStatus
  public static let conflict: patrol.HTTPStatus
  public static let gone: patrol.HTTPStatus
  public static let lengthRequired: patrol.HTTPStatus
  public static let preconditionFailed: patrol.HTTPStatus
  public static let payloadTooLarge: patrol.HTTPStatus
  public static let uriTooLong: patrol.HTTPStatus
  public static let unsupportedMediaType: patrol.HTTPStatus
  public static let rangeNotSatisfiable: patrol.HTTPStatus
  public static let expectationFailed: patrol.HTTPStatus
  public static let misdirectedRequest: patrol.HTTPStatus
  public static let unprocessableEntity: patrol.HTTPStatus
  public static let locked: patrol.HTTPStatus
  public static let failedDependency: patrol.HTTPStatus
  public static let upgradeRequired: patrol.HTTPStatus
  public static let preconditionRequired: patrol.HTTPStatus
  public static let tooManyRequests: patrol.HTTPStatus
  public static let requestHeaderFieldsTooLarge: patrol.HTTPStatus
  public static let unavailableForLegalReasons: patrol.HTTPStatus
}
extension patrol.HTTPStatus {
  public static let internalServerError: patrol.HTTPStatus
  public static let notImplemented: patrol.HTTPStatus
  public static let badGateway: patrol.HTTPStatus
  public static let serviceUnavailable: patrol.HTTPStatus
  public static let gatewayTimeout: patrol.HTTPStatus
  public static let httpVersionNotSupported: patrol.HTTPStatus
  public static let variantAlsoNegotiates: patrol.HTTPStatus
  public static let insufficientStorage: patrol.HTTPStatus
  public static let loopDetected: patrol.HTTPStatus
  public static let notExtended: patrol.HTTPStatus
  public static let networkAuthenticationRequired: patrol.HTTPStatus
}
public struct HTTPVersion {
  public let major: Swift.UInt
  public let minor: Swift.UInt
  public init(major: Swift.UInt, minor: Swift.UInt)
}
extension patrol.HTTPVersion {
  public static let `default`: patrol.HTTPVersion
}
extension patrol.HTTPVersion : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
open class HTTPWebSocketHandler : patrol.HTTPRequestHandler {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(protocolName: Swift.String? = nil)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func respond(to request: patrol.HTTPRequest, nextHandler: (patrol.HTTPRequest) throws -> patrol.HTTPResponse?) throws -> patrol.HTTPResponse?
  #endif
  @objc deinit
}
public enum KeychainError : Swift.Error {
  case invalidResult
  case itemAlreadyExists
  case itemNotFound
  case other(code: Darwin.OSStatus)
}
extension patrol.KeychainError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.KeychainError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
@_hasMissingDesignatedInitializers public class KeychainManager {
  public static let shared: patrol.KeychainManager
  public var accessibility: CoreFoundation.CFString
  public typealias KeychainClass = CoreFoundation.CFString
  public typealias KeychainValue = Swift.AnyObject
  public typealias KeychainQuery = [Foundation.NSString : Swift.AnyObject]
  @objc deinit
}
extension patrol.KeychainManager {
  #if compiler(>=5.3) && $NonescapableTypes
  public func importPKCS12(data: Foundation.Data, passphrase: Swift.String, options: patrol.KeychainManager.KeychainQuery = KeychainQuery()) -> Security.SecIdentity?
  #endif
}
extension patrol.KeychainManager {
  public func add(value: patrol.KeychainManager.KeychainValue, label: Swift.String, options: patrol.KeychainManager.KeychainQuery = KeychainQuery()) throws
  public func find<T>(_ kClass: patrol.KeychainManager.KeychainClass, label: Swift.String, options: patrol.KeychainManager.KeychainQuery = KeychainQuery()) throws -> T
  public func remove(_ kClass: patrol.KeychainManager.KeychainClass, label: Swift.String, options: patrol.KeychainManager.KeychainQuery = KeychainQuery()) throws
}
public typealias Regex = Foundation.NSRegularExpression
@objc public class ObjCRunDartTestResponse : ObjectiveC.NSObject {
  @objc dynamic final public let passed: Swift.Bool
  @objc dynamic final public let details: Swift.String?
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public init(passed: Swift.Bool, details: Swift.String?)
  #endif
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class ObjCPatrolAppServiceClient : ObjectiveC.NSObject {
  @objc override dynamic public init()
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public func listDartTests(completion: @escaping ([[Swift.String : Any]]?, (any Swift.Error)?) -> Swift.Void)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  @objc public func runDartTest(name: Swift.String, completion: @escaping (patrol.ObjCRunDartTestResponse?, (any Swift.Error)?) -> Swift.Void)
  #endif
  @objc deinit
}
@_inheritsConvenienceInitializers @objc public class PatrolServer : ObjectiveC.NSObject {
  @objc public var appReady: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  @objc public func start() throws
  @objc deinit
}
public struct RFC1123 {
  public static var formatter: Foundation.DateFormatter
}
extension Foundation.DateFormatter {
  public static var rfc1123: Foundation.DateFormatter {
    get
  }
}
extension Foundation.Date {
  public var rfc1123: Swift.String {
    get
  }
}
open class Server {
  weak public var delegate: (any patrol.ServerDelegate)?
  public var delegateQueue: Dispatch.DispatchQueue
  public var httpConfig: patrol.HTTPConfig
  public var webSocketConfig: patrol.WebSocketConfig
  weak public var webSocketDelegate: (any patrol.ServerWebSocketDelegate)?
  public init()
  public init(identity: patrol.CertificateIdentity, caCertificates: [patrol.Certificate])
  #if compiler(>=5.3) && $NonescapableTypes
  open func start(port: patrol.Endpoint.Port = 0, interface: Swift.String? = nil) throws
  #endif
  open func stop(immediately: Swift.Bool = false)
  open func handleIncoming(socket: patrol.TCPSocket)
  #if compiler(>=5.3) && $NonescapableTypes
  open func handleIncoming(request: patrol.HTTPRequest, connection: patrol.HTTPConnection, error: (any Swift.Error)?)
  #endif
  open func handleUpgrade(request: patrol.HTTPRequest, connection: patrol.HTTPConnection)
  #if compiler(>=5.3) && $NonescapableTypes
  open func responseFor(request: patrol.HTTPRequest) throws -> patrol.HTTPResponse?
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  open func responseFor(error: any Swift.Error) -> patrol.HTTPResponse?
  #endif
  @objc deinit
}
extension patrol.Server {
  public var concurrency: Swift.Int {
    get
    set
  }
  public var port: patrol.Endpoint.Port {
    get
  }
  public var isRunning: Swift.Bool {
    get
  }
  public var isSecure: Swift.Bool {
    get
  }
  public var httpConnections: Swift.Set<patrol.HTTPConnection> {
    get
  }
  public var httpConnectionCount: Swift.Int {
    get
  }
  public var webSocketConnections: Swift.Set<patrol.WebSocketConnection> {
    get
  }
  public var webSockets: [any patrol.WebSocket] {
    get
  }
  public var webSocketCount: Swift.Int {
    get
  }
}
extension patrol.Server : patrol.TCPListenerDelegate {
  public func listener(_ listener: patrol.TCPListener, didAcceptSocket socket: patrol.TCPSocket)
  #if compiler(>=5.3) && $NonescapableTypes
  public func listenerDisconnected(_ listener: patrol.TCPListener, error: (any Swift.Error)?)
  #endif
}
extension patrol.Server : patrol.HTTPConnectionDelegate {
  #if compiler(>=5.3) && $NonescapableTypes
  public func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingRequest request: patrol.HTTPRequest, error: (any Swift.Error)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingResponse response: patrol.HTTPResponse, error: (any Swift.Error)?)
  #endif
  public func connection(_ httpConnection: patrol.HTTPConnection, handleUpgradeByRequest request: patrol.HTTPRequest)
  #if compiler(>=5.3) && $NonescapableTypes
  public func connection(_ httpConnection: patrol.HTTPConnection, didCloseWithError error: (any Swift.Error)?)
  #endif
}
extension patrol.Server : patrol.WebSocketConnectionDelegate {
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didReceiveMessage message: patrol.WebSocketMessage)
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didSendMessage message: patrol.WebSocketMessage)
  #if compiler(>=5.3) && $NonescapableTypes
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didCloseWithError error: (any Swift.Error)?)
  #endif
}
extension patrol.HTTPConfig {
  public static var serverDefault: patrol.HTTPConfig {
    get
  }
}
extension patrol.WebSocketConfig {
  public static var serverDefault: patrol.WebSocketConfig {
    get
  }
}
extension patrol.Server {
  public func route(_ method: patrol.HTTPMethod, _ uri: Swift.String, _ handler: @escaping patrol.HTTPRequest.Handler)
  public func route(_ method: patrol.HTTPMethod, regex: Swift.String, _ handler: @escaping patrol.HTTPRequest.Handler)
  public func route(_ httpRoute: patrol.HTTPRoute)
}
extension patrol.Server {
  public func route(_ method: patrol.HTTPMethod, _ uri: Swift.String, response: @escaping () -> patrol.HTTPResponse)
  public func route(_ method: patrol.HTTPMethod, _ uri: Swift.String, status: @escaping () -> patrol.HTTPStatus)
  public func route(_ method: patrol.HTTPMethod, _ uri: Swift.String, content: @escaping () -> (patrol.HTTPStatus, Swift.String))
}
public protocol ServerDelegate : AnyObject {
  #if compiler(>=5.3) && $NonescapableTypes
  func serverDidStop(_ server: patrol.Server, error: (any Swift.Error)?)
  #endif
}
public protocol ServerWebSocketDelegate : AnyObject {
  func server(_ server: patrol.Server, webSocketDidConnect webSocket: any patrol.WebSocket, handshake: patrol.HTTPRequest)
  #if compiler(>=5.3) && $NonescapableTypes
  func server(_ server: patrol.Server, webSocketDidDisconnect webSocket: any patrol.WebSocket, error: (any Swift.Error)?)
  #endif
  func server(_ server: patrol.Server, webSocket: any patrol.WebSocket, didReceiveMessage message: patrol.WebSocketMessage)
  func server(_ server: patrol.Server, webSocket: any patrol.WebSocket, didSendMessage message: patrol.WebSocketMessage)
  func serverDidDisconnect(_ server: patrol.Server)
}
extension patrol.ServerWebSocketDelegate {
  public func server(_ server: patrol.Server, webSocket: any patrol.WebSocket, didSendMessage message: patrol.WebSocketMessage)
  public func serverDidDisconnect(_ server: patrol.Server)
}
public struct SHA1 {
  public let digest: Foundation.Data
  public init(data: Foundation.Data)
}
extension patrol.SHA1 {
  public static func hash(_ data: Foundation.Data) -> Foundation.Data
  public static func hash(_ string: Swift.String) -> Foundation.Data
}
public protocol ReadStream {
  func read(timeout: Foundation.TimeInterval)
}
public protocol WriteStream {
  func flush()
  func write(data: Foundation.Data, timeout: Foundation.TimeInterval)
}
extension Swift.String {
  public var base64: Swift.String {
    get
  }
  public var utf8Data: Foundation.Data {
    get
  }
  public func truncate(count: Swift.Int, ellipses: Swift.Bool = true) -> Swift.String
}
@objc @_inheritsConvenienceInitializers public class SwiftPatrolPlugin : ObjectiveC.NSObject, Flutter.FlutterPlugin {
  @objc public static func register(with registrar: any Flutter.FlutterPluginRegistrar)
  @objc public func handle(_ call: Flutter.FlutterMethodCall, result: @escaping Flutter.FlutterResult)
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SynchronizedSet<Element> where Element : Swift.Hashable {
  @objc deinit
}
extension patrol.SynchronizedSet {
  public var count: Swift.Int {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var description: Swift.String {
    get
  }
}
extension patrol.SynchronizedSet {
  public func insert(_ element: Element)
  public func remove(_ element: Element)
}
extension patrol.SynchronizedSet {
  public func contains(_ element: Element) -> Swift.Bool
  public func forEach(_ body: (Element) -> Swift.Void)
}
extension patrol.SynchronizedSet {
  public func toArray() -> [Element]
  public func toSet() -> Swift.Set<Element>
}
public protocol TCPConnection : AnyObject, Swift.Hashable {
  #if compiler(>=5.3) && $NonescapableTypes
  var localEndpoint: patrol.Endpoint? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var remoteEndpoint: patrol.Endpoint? { get }
  #endif
  func open()
  func close(immediately: Swift.Bool)
}
extension patrol.TCPConnection {
  public static func == (lhs: Self, rhs: Self) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
}
public protocol TCPListenerDelegate : AnyObject {
  func listener(_ listener: patrol.TCPListener, didAcceptSocket socket: patrol.TCPSocket)
  #if compiler(>=5.3) && $NonescapableTypes
  func listenerDisconnected(_ listener: patrol.TCPListener, error: (any Swift.Error)?)
  #endif
}
@objc final public class TCPListener : ObjectiveC.NSObject {
  weak final public var delegate: (any patrol.TCPListenerDelegate)?
  final public let interface: Swift.String?
  final public let tlsConfig: patrol.TLSConfig?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(port: patrol.Endpoint.Port, interface: Swift.String? = nil, tlsConfig: patrol.TLSConfig? = nil)
  #endif
  final public var isListening: Swift.Bool {
    get
  }
  final public var port: patrol.Endpoint.Port {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  #endif
  final public func start(queue: Dispatch.DispatchQueue) throws
  final public func stop()
  @objc deinit
}
extension patrol.TCPListener : CocoaAsyncSocket.GCDAsyncSocketDelegate {
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didAcceptNewSocket newSocket: CocoaAsyncSocket.GCDAsyncSocket)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func socketDidDisconnect(_ sock: CocoaAsyncSocket.GCDAsyncSocket, withError err: (any Swift.Error)?)
  #endif
}
public enum TCPSocketClose {
  case immediately
  case afterReading
  case afterWriting
  case afterReadingAndWriting
  public static func == (a: patrol.TCPSocketClose, b: patrol.TCPSocketClose) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TCPSocketDelegate : AnyObject {
  func socketDidOpen(_ socket: patrol.TCPSocket)
  #if compiler(>=5.3) && $NonescapableTypes
  func socketDidClose(_ socket: patrol.TCPSocket, error: (any Swift.Error)?)
  #endif
  func socketDidRead(_ socket: patrol.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  func socketDidWrite(_ socket: patrol.TCPSocket, tag: Swift.Int)
}
@objc @_hasMissingDesignatedInitializers final public class TCPSocket : ObjectiveC.NSObject {
  final public let endpoint: patrol.Endpoint
  weak final public var delegate: (any patrol.TCPSocketDelegate)?
  #if compiler(>=5.3) && $NonescapableTypes
  public init(endpoint: patrol.Endpoint, tlsPolicy: patrol.TLSPolicy? = nil)
  #endif
  final public var isConnected: Swift.Bool {
    get
  }
  #if compiler(>=5.3) && $NonescapableTypes
  final public var localEndpoint: patrol.Endpoint? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var remoteEndpoint: patrol.Endpoint? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  final public var queue: Dispatch.DispatchQueue? {
    get
  }
  #endif
  final public func setDelegate(_ delegate: any patrol.TCPSocketDelegate, queue: Dispatch.DispatchQueue)
  final public func setDelegateQueue(_ queue: Dispatch.DispatchQueue)
  final public func connect(timeout: Foundation.TimeInterval = 30)
  final public func close(when: patrol.TCPSocketClose = .immediately)
  final public func read(timeout: Foundation.TimeInterval = -1, tag: Swift.Int = 0)
  final public func read(maxLength: Swift.Int, timeout: Foundation.TimeInterval = -1, tag: Swift.Int = 0)
  final public func write(data: Foundation.Data, timeout: Foundation.TimeInterval = -1, tag: Swift.Int = 0)
  final public func startTLS(config: patrol.TLSConfig = TLSConfig())
  @objc deinit
}
extension patrol.TCPSocket : patrol.ReadStream, patrol.WriteStream {
  final public func read(timeout: Foundation.TimeInterval)
  final public func write(data: Foundation.Data, timeout: Foundation.TimeInterval)
  final public func flush()
}
extension patrol.TCPSocket : CocoaAsyncSocket.GCDAsyncSocketDelegate {
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didConnectToHost host: Swift.String, port: Swift.UInt16)
  #if compiler(>=5.3) && $NonescapableTypes
  @objc final public func socketDidDisconnect(_ sock: CocoaAsyncSocket.GCDAsyncSocket, withError err: (any Swift.Error)?)
  #endif
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didRead data: Foundation.Data, withTag tag: Swift.Int)
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didWriteDataWithTag tag: Swift.Int)
  @objc final public func socket(_ sock: CocoaAsyncSocket.GCDAsyncSocket, didReceive trust: Security.SecTrust, completionHandler: @escaping (Swift.Bool) -> Swift.Void)
}
public struct TLSConfig {
  public let identity: patrol.CertificateIdentity?
  public let certificates: [patrol.Certificate]
  public init(serverIdentity: patrol.CertificateIdentity, caCertificates: [patrol.Certificate])
  public init(clientCertificates: [patrol.Certificate] = [])
}
open class TLSPolicy {
  public var commonName: Swift.String?
  public var certificates: [patrol.Certificate]
  #if compiler(>=5.3) && $NonescapableTypes
  public init(commonName: Swift.String? = nil, certificates: [patrol.Certificate] = [])
  #endif
  public func evaluate(trust: Security.SecTrust) -> Swift.Bool
  @objc deinit
}
extension patrol.TLSPolicy {
  #if compiler(>=5.3) && $NonescapableTypes
  public func evaluateSession(trust: Security.SecTrust?) -> Foundation.URLCredential?
  #endif
}
extension Swift.UInt8 {
  public static var random: Swift.UInt8 {
    get
  }
}
extension Swift.UInt16 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.UInt32 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
extension Swift.UInt64 {
  public var bytes: [Swift.UInt8] {
    get
  }
}
public struct URI : Swift.Hashable, Swift.Equatable {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(path: Swift.String = "/", query: Swift.String? = nil)
  #endif
  public init(components: Foundation.URLComponents)
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(url: Foundation.URL)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(_ string: Swift.String)
  #endif
  public static func == (a: patrol.URI, b: patrol.URI) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.URI {
  public var path: Swift.String {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var query: Swift.String? {
    get
    set
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var queryItems: [Foundation.URLQueryItem]? {
    get
    set
  }
  #endif
}
extension patrol.URI {
  #if compiler(>=5.3) && $NonescapableTypes
  public init(percentEncodedPath: Swift.String, percentEncodedQuery: Swift.String? = nil)
  #endif
  public var percentEncodedPath: Swift.String {
    get
    set
  }
  #if compiler(>=5.3) && $NonescapableTypes
  public var percentEncodedQuery: Swift.String? {
    get
    set
  }
  #endif
  public var string: Swift.String {
    get
  }
}
extension patrol.URI {
  public static let root: patrol.URI
  #if compiler(>=5.3) && $NonescapableTypes
  public func relativePath(from path: Swift.String) -> Swift.String?
  #endif
}
extension patrol.URI : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension Foundation.URL {
  public var hasWebSocketScheme: Swift.Bool {
    get
  }
  public var portBasedOnScheme: Swift.Int {
    get
  }
  public var isSchemeSecure: Swift.Bool {
    get
  }
}
extension Foundation.URL {
  public var mimeType: Swift.String {
    get
  }
}
public protocol WebSocket : AnyObject {
  #if compiler(>=5.3) && $NonescapableTypes
  var localEndpoint: patrol.Endpoint? { get }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  var remoteEndpoint: patrol.Endpoint? { get }
  #endif
  func close(immediately: Swift.Bool)
  func send(data: Foundation.Data)
  func send(text: Swift.String)
  func send(message: patrol.WebSocketMessage)
}
extension patrol.WebSocket {
  public func send(data: Foundation.Data)
  public func send(text: Swift.String)
}
public protocol WebSocketClientDelegate : AnyObject {
  func webSocketClient(_ client: patrol.WebSocketClient, didConnectToHost host: Swift.String)
  #if compiler(>=5.3) && $NonescapableTypes
  func webSocketClient(_ client: patrol.WebSocketClient, didDisconnectWithError error: (any Swift.Error)?)
  #endif
  func webSocketClient(_ client: patrol.WebSocketClient, didReceiveData data: Foundation.Data)
  func webSocketClient(_ client: patrol.WebSocketClient, didReceiveText text: Swift.String)
}
open class WebSocketClient : patrol.WebSocket {
  final public let url: Foundation.URL
  public var headers: patrol.HTTPHeaders
  public var config: patrol.WebSocketConfig
  public var tlsPolicy: patrol.TLSPolicy?
  weak public var delegate: (any patrol.WebSocketClientDelegate)?
  public init(url: Foundation.URL, headers: patrol.HTTPHeaders = .empty) throws
  public func connect(timeout: Foundation.TimeInterval = 10)
  public func disconnect()
  public func close(immediately: Swift.Bool)
  public func send(message: patrol.WebSocketMessage)
  @objc deinit
}
extension patrol.WebSocketClient {
  #if compiler(>=5.3) && $NonescapableTypes
  public var localEndpoint: patrol.Endpoint? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var remoteEndpoint: patrol.Endpoint? {
    get
  }
  #endif
}
extension patrol.WebSocketClient {
  convenience public init(_ string: Swift.String) throws
  convenience public init(_ string: Swift.String, certificates: [patrol.Certificate]) throws
  convenience public init(url: Foundation.URL, certificates: [patrol.Certificate]) throws
}
extension patrol.WebSocketClient : patrol.TCPSocketDelegate {
  public func socketDidOpen(_ socket: patrol.TCPSocket)
  #if compiler(>=5.3) && $NonescapableTypes
  public func socketDidClose(_ socket: patrol.TCPSocket, error: (any Swift.Error)?)
  #endif
  public func socketDidRead(_ socket: patrol.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  public func socketDidWrite(_ socket: patrol.TCPSocket, tag: Swift.Int)
}
extension patrol.WebSocketClient : patrol.HTTPConnectionDelegate {
  #if compiler(>=5.3) && $NonescapableTypes
  public func connection(_ httpConnection: patrol.HTTPConnection, didCloseWithError error: (any Swift.Error)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingResponse response: patrol.HTTPResponse, error: (any Swift.Error)?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func connection(_ httpConnection: patrol.HTTPConnection, handleIncomingRequest request: patrol.HTTPRequest, error: (any Swift.Error)?)
  #endif
  public func connection(_ httpConnection: patrol.HTTPConnection, handleUpgradeByRequest request: patrol.HTTPRequest)
}
extension patrol.WebSocketClient : patrol.WebSocketConnectionDelegate {
  #if compiler(>=5.3) && $NonescapableTypes
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didCloseWithError error: (any Swift.Error)?)
  #endif
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didReceiveMessage message: patrol.WebSocketMessage)
  public func connection(_ webSocketConnection: patrol.WebSocketConnection, didSendMessage message: patrol.WebSocketMessage)
}
public struct WebSocketConfig {
  public var readTimeout: Swift.Double
  public var writeHeaderTimeout: Swift.Double
  public var writePayloadTimeout: Swift.Double
  public var maskMessages: Swift.Bool
  public var pingInterval: Swift.Double
  public var errorHandler: any patrol.WebSocketErrorHandler
  public var messageHandler: any patrol.WebSocketMessageHandler
  public init()
}
public protocol WebSocketConnectionDelegate : AnyObject {
  func connection(_ webSocketConnection: patrol.WebSocketConnection, didReceiveMessage message: patrol.WebSocketMessage)
  func connection(_ webSocketConnection: patrol.WebSocketConnection, didSendMessage message: patrol.WebSocketMessage)
  #if compiler(>=5.3) && $NonescapableTypes
  func connection(_ webSocketConnection: patrol.WebSocketConnection, didCloseWithError error: (any Swift.Error)?)
  #endif
}
open class WebSocketConnection : patrol.TCPConnection, patrol.WebSocket {
  weak public var delegate: (any patrol.WebSocketConnectionDelegate)?
  required public init(socket: patrol.TCPSocket, config: patrol.WebSocketConfig)
  public func open()
  #if compiler(>=5.3) && $NonescapableTypes
  public func open(data: Foundation.Data?)
  #endif
  public func close(immediately: Swift.Bool)
  public func send(message: patrol.WebSocketMessage)
  @objc deinit
  open var hashValue: Swift.Int {
    get
  }
}
extension patrol.WebSocketConnection {
  #if compiler(>=5.3) && $NonescapableTypes
  public var localEndpoint: patrol.Endpoint? {
    get
  }
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public var remoteEndpoint: patrol.Endpoint? {
    get
  }
  #endif
}
extension patrol.WebSocketConnection : patrol.TCPSocketDelegate {
  public func socketDidOpen(_ socket: patrol.TCPSocket)
  #if compiler(>=5.3) && $NonescapableTypes
  public func socketDidClose(_ socket: patrol.TCPSocket, error: (any Swift.Error)?)
  #endif
  public func socketDidRead(_ socket: patrol.TCPSocket, data: Foundation.Data, tag: Swift.Int)
  public func socketDidWrite(_ socket: patrol.TCPSocket, tag: Swift.Int)
}
extension patrol.WebSocketConnection : patrol.WebSocketParserDelegate {
  public func parser(_ parser: patrol.WebSocketParser, didCompleteMessage message: patrol.WebSocketMessage)
}
public enum WebSocketError : Swift.Error {
  case invalidMessage
  case invalidOpcode
  case invalidPayloadLength
  case payloadIsNotText
  case payloadTooLarge
  public static func == (a: patrol.WebSocketError, b: patrol.WebSocketError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension patrol.WebSocketError {
  public var code: Swift.UInt16 {
    get
  }
}
extension patrol.WebSocketError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.WebSocketError : Foundation.LocalizedError {
  #if compiler(>=5.3) && $NonescapableTypes
  public var errorDescription: Swift.String? {
    get
  }
  #endif
}
@_hasMissingDesignatedInitializers public class WebSocketErrorDefaultHandler : patrol.WebSocketErrorHandler {
  #if compiler(>=5.3) && $NonescapableTypes
  public func incoming(error: any Swift.Error, webSocket: any patrol.WebSocket, message: patrol.WebSocketMessage?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  public func outgoing(error: any Swift.Error, webSocket: any patrol.WebSocket, message: patrol.WebSocketMessage?)
  #endif
  @objc deinit
}
public protocol WebSocketErrorHandler {
  #if compiler(>=5.3) && $NonescapableTypes
  func incoming(error: any Swift.Error, webSocket: any patrol.WebSocket, message: patrol.WebSocketMessage?)
  #endif
  #if compiler(>=5.3) && $NonescapableTypes
  func outgoing(error: any Swift.Error, webSocket: any patrol.WebSocket, message: patrol.WebSocketMessage?)
  #endif
}
open class WebSocketMessage {
  public var finBit: Swift.Bool
  public var maskBit: Swift.Bool
  public var opcode: patrol.WebSocketOpcode
  public var payload: patrol.WebSocketPayload
  public init(opcode: patrol.WebSocketOpcode = .connectionClose, payload: patrol.WebSocketPayload = .none)
  @objc deinit
}
public enum WebSocketOpcode : Swift.UInt8 {
  case continuationFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  #if compiler(>=5.3) && $NonescapableTypes
  public init?(rawValue: Swift.UInt8)
  #endif
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public enum WebSocketPayload {
  case none
  case binary(Foundation.Data)
  case text(Swift.String)
  case close(code: Swift.UInt16, reason: Swift.String)
}
public struct WebSocketMasks {
}
extension patrol.WebSocketMessage {
  convenience public init(closeCode: Swift.UInt16, reason: Swift.String = "")
  convenience public init(error: patrol.WebSocketError)
  convenience public init(data: Foundation.Data)
  convenience public init(text: Swift.String)
}
extension patrol.WebSocketMessage {
  public func generateMask() -> [Swift.UInt8]
}
extension patrol.WebSocketMessage : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension patrol.WebSocketMessage {
  public func write(to stream: any patrol.WriteStream, headerTimeout: Foundation.TimeInterval, payloadTimeout: Foundation.TimeInterval)
}
extension patrol.WebSocketPayload {
  #if compiler(>=5.3) && $NonescapableTypes
  public var data: Foundation.Data? {
    get
  }
  #endif
}
@_hasMissingDesignatedInitializers public class WebSocketMessageDefaultHandler : patrol.WebSocketMessageHandler {
  public func incoming(message: patrol.WebSocketMessage, from webSocket: any patrol.WebSocket) throws
  public func outgoing(message: patrol.WebSocketMessage, to webSocket: any patrol.WebSocket) throws
  @objc deinit
}
public protocol WebSocketMessageHandler {
  func incoming(message: patrol.WebSocketMessage, from webSocket: any patrol.WebSocket) throws
  func outgoing(message: patrol.WebSocketMessage, to webSocket: any patrol.WebSocket) throws
}
public protocol WebSocketParserDelegate : AnyObject {
  func parser(_ parser: patrol.WebSocketParser, didCompleteMessage message: patrol.WebSocketMessage)
}
public class WebSocketParser {
  final public let maxPayloadLength: Swift.UInt64
  weak public var delegate: (any patrol.WebSocketParserDelegate)?
  public var message: patrol.WebSocketMessage {
    get
  }
  public var maskingKey: [Swift.UInt8] {
    get
  }
  public var payload: Foundation.Data {
    get
  }
  public var nextPart: patrol.WebSocketParser.Part {
    get
  }
  public var bytesParsed: Swift.Int {
    get
  }
  public var payloadLength: Swift.UInt64 {
    get
  }
  public enum Part {
    case finAndOpcode
    case maskAndPayloadLength
    case extendedPayloadLength16(byteNo: Swift.Int)
    case extendedPayloadLength64(byteNo: Swift.Int)
    case maskingKey(byteNo: Swift.Int)
    case payload
    case endOfMessage
  }
  public init(maxPayloadLength: Swift.Int = 10_485_760)
  public func parse(data: Foundation.Data) throws
  public func reset()
  @objc deinit
}
extension patrol.GroupEntryType : Swift.Equatable {}
extension patrol.GroupEntryType : Swift.Hashable {}
extension patrol.GroupEntryType : Swift.RawRepresentable {}
extension patrol.RunDartTestResponseResult : Swift.Equatable {}
extension patrol.RunDartTestResponseResult : Swift.Hashable {}
extension patrol.RunDartTestResponseResult : Swift.RawRepresentable {}
extension patrol.KeyboardBehavior : Swift.Equatable {}
extension patrol.KeyboardBehavior : Swift.Hashable {}
extension patrol.KeyboardBehavior : Swift.RawRepresentable {}
extension patrol.HandlePermissionRequestCode : Swift.Equatable {}
extension patrol.HandlePermissionRequestCode : Swift.Hashable {}
extension patrol.HandlePermissionRequestCode : Swift.RawRepresentable {}
extension patrol.SetLocationAccuracyRequestLocationAccuracy : Swift.Equatable {}
extension patrol.SetLocationAccuracyRequestLocationAccuracy : Swift.Hashable {}
extension patrol.SetLocationAccuracyRequestLocationAccuracy : Swift.RawRepresentable {}
extension patrol.IOSElementType : Swift.Equatable {}
extension patrol.IOSElementType : Swift.Hashable {}
extension patrol.IOSElementType : Swift.RawRepresentable {}
@available(*, deprecated, message: "these specific errors are no longer thrown")
extension patrol.HTTPRouteError : Swift.Equatable {}
@available(*, deprecated, message: "these specific errors are no longer thrown")
extension patrol.HTTPRouteError : Swift.Hashable {}
extension patrol.TCPSocketClose : Swift.Equatable {}
extension patrol.TCPSocketClose : Swift.Hashable {}
extension patrol.WebSocketError : Swift.Equatable {}
extension patrol.WebSocketError : Swift.Hashable {}
extension patrol.WebSocketOpcode : Swift.Equatable {}
extension patrol.WebSocketOpcode : Swift.Hashable {}
extension patrol.WebSocketOpcode : Swift.RawRepresentable {}
